// Code generated by Kitex v0.13.1. DO NOT EDIT.

package viewservice

import (
	"context"
	"errors"
	client "github.com/cloudwego/kitex/client"
	kitex "github.com/cloudwego/kitex/pkg/serviceinfo"
	streaming "github.com/cloudwego/kitex/pkg/streaming"
	proto "github.com/cloudwego/prutal"
	basic "github.com/xh-polaris/psych-idl/kitex_gen/basic"
	user "github.com/xh-polaris/psych-idl/kitex_gen/user"
)

var errInvalidMessageType = errors.New("invalid message type for service method handler")

var serviceMethods = map[string]kitex.MethodInfo{
	"ViewSignUp": kitex.NewMethodInfo(
		viewSignUpHandler,
		newViewSignUpArgs,
		newViewSignUpResult,
		false,
		kitex.WithStreamingMode(kitex.StreamingUnary),
	),
	"ViewGetInfo": kitex.NewMethodInfo(
		viewGetInfoHandler,
		newViewGetInfoArgs,
		newViewGetInfoResult,
		false,
		kitex.WithStreamingMode(kitex.StreamingUnary),
	),
	"ViewUpdateInfo": kitex.NewMethodInfo(
		viewUpdateInfoHandler,
		newViewUpdateInfoArgs,
		newViewUpdateInfoResult,
		false,
		kitex.WithStreamingMode(kitex.StreamingUnary),
	),
	"ViewUpdatePassword": kitex.NewMethodInfo(
		viewUpdatePasswordHandler,
		newViewUpdatePasswordArgs,
		newViewUpdatePasswordResult,
		false,
		kitex.WithStreamingMode(kitex.StreamingUnary),
	),
	"ViewBelongUnit": kitex.NewMethodInfo(
		viewBelongUnitHandler,
		newViewBelongUnitArgs,
		newViewBelongUnitResult,
		false,
		kitex.WithStreamingMode(kitex.StreamingUnary),
	),
	"ViewSignIn": kitex.NewMethodInfo(
		viewSignInHandler,
		newViewSignInArgs,
		newViewSignInResult,
		false,
		kitex.WithStreamingMode(kitex.StreamingUnary),
	),
}

var (
	viewServiceServiceInfo                = NewServiceInfo()
	viewServiceServiceInfoForClient       = NewServiceInfoForClient()
	viewServiceServiceInfoForStreamClient = NewServiceInfoForStreamClient()
)

// for server
func serviceInfo() *kitex.ServiceInfo {
	return viewServiceServiceInfo
}

// for stream client
func serviceInfoForStreamClient() *kitex.ServiceInfo {
	return viewServiceServiceInfoForStreamClient
}

// for client
func serviceInfoForClient() *kitex.ServiceInfo {
	return viewServiceServiceInfoForClient
}

// NewServiceInfo creates a new ServiceInfo containing all methods
func NewServiceInfo() *kitex.ServiceInfo {
	return newServiceInfo(false, true, true)
}

// NewServiceInfo creates a new ServiceInfo containing non-streaming methods
func NewServiceInfoForClient() *kitex.ServiceInfo {
	return newServiceInfo(false, false, true)
}
func NewServiceInfoForStreamClient() *kitex.ServiceInfo {
	return newServiceInfo(true, true, false)
}

func newServiceInfo(hasStreaming bool, keepStreamingMethods bool, keepNonStreamingMethods bool) *kitex.ServiceInfo {
	serviceName := "ViewService"
	handlerType := (*user.ViewService)(nil)
	methods := map[string]kitex.MethodInfo{}
	for name, m := range serviceMethods {
		if m.IsStreaming() && !keepStreamingMethods {
			continue
		}
		if !m.IsStreaming() && !keepNonStreamingMethods {
			continue
		}
		methods[name] = m
	}
	extra := map[string]interface{}{
		"PackageName": "user",
	}
	if hasStreaming {
		extra["streaming"] = hasStreaming
	}
	svcInfo := &kitex.ServiceInfo{
		ServiceName:     serviceName,
		HandlerType:     handlerType,
		Methods:         methods,
		PayloadCodec:    kitex.Protobuf,
		KiteXGenVersion: "v0.13.1",
		Extra:           extra,
	}
	return svcInfo
}

func viewSignUpHandler(ctx context.Context, handler interface{}, arg, result interface{}) error {
	switch s := arg.(type) {
	case *streaming.Args:
		st := s.Stream
		req := new(user.ViewSignUpReq)
		if err := st.RecvMsg(req); err != nil {
			return err
		}
		resp, err := handler.(user.ViewService).ViewSignUp(ctx, req)
		if err != nil {
			return err
		}
		return st.SendMsg(resp)
	case *ViewSignUpArgs:
		success, err := handler.(user.ViewService).ViewSignUp(ctx, s.Req)
		if err != nil {
			return err
		}
		realResult := result.(*ViewSignUpResult)
		realResult.Success = success
		return nil
	default:
		return errInvalidMessageType
	}
}
func newViewSignUpArgs() interface{} {
	return &ViewSignUpArgs{}
}

func newViewSignUpResult() interface{} {
	return &ViewSignUpResult{}
}

type ViewSignUpArgs struct {
	Req *user.ViewSignUpReq
}

func (p *ViewSignUpArgs) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetReq() {
		return out, nil
	}
	return proto.Marshal(p.Req)
}

func (p *ViewSignUpArgs) Unmarshal(in []byte) error {
	msg := new(user.ViewSignUpReq)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Req = msg
	return nil
}

var ViewSignUpArgs_Req_DEFAULT *user.ViewSignUpReq

func (p *ViewSignUpArgs) GetReq() *user.ViewSignUpReq {
	if !p.IsSetReq() {
		return ViewSignUpArgs_Req_DEFAULT
	}
	return p.Req
}

func (p *ViewSignUpArgs) IsSetReq() bool {
	return p.Req != nil
}

func (p *ViewSignUpArgs) GetFirstArgument() interface{} {
	return p.Req
}

type ViewSignUpResult struct {
	Success *basic.Response
}

var ViewSignUpResult_Success_DEFAULT *basic.Response

func (p *ViewSignUpResult) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetSuccess() {
		return out, nil
	}
	return proto.Marshal(p.Success)
}

func (p *ViewSignUpResult) Unmarshal(in []byte) error {
	msg := new(basic.Response)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Success = msg
	return nil
}

func (p *ViewSignUpResult) GetSuccess() *basic.Response {
	if !p.IsSetSuccess() {
		return ViewSignUpResult_Success_DEFAULT
	}
	return p.Success
}

func (p *ViewSignUpResult) SetSuccess(x interface{}) {
	p.Success = x.(*basic.Response)
}

func (p *ViewSignUpResult) IsSetSuccess() bool {
	return p.Success != nil
}

func (p *ViewSignUpResult) GetResult() interface{} {
	return p.Success
}

func viewGetInfoHandler(ctx context.Context, handler interface{}, arg, result interface{}) error {
	switch s := arg.(type) {
	case *streaming.Args:
		st := s.Stream
		req := new(user.ViewGetInfoReq)
		if err := st.RecvMsg(req); err != nil {
			return err
		}
		resp, err := handler.(user.ViewService).ViewGetInfo(ctx, req)
		if err != nil {
			return err
		}
		return st.SendMsg(resp)
	case *ViewGetInfoArgs:
		success, err := handler.(user.ViewService).ViewGetInfo(ctx, s.Req)
		if err != nil {
			return err
		}
		realResult := result.(*ViewGetInfoResult)
		realResult.Success = success
		return nil
	default:
		return errInvalidMessageType
	}
}
func newViewGetInfoArgs() interface{} {
	return &ViewGetInfoArgs{}
}

func newViewGetInfoResult() interface{} {
	return &ViewGetInfoResult{}
}

type ViewGetInfoArgs struct {
	Req *user.ViewGetInfoReq
}

func (p *ViewGetInfoArgs) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetReq() {
		return out, nil
	}
	return proto.Marshal(p.Req)
}

func (p *ViewGetInfoArgs) Unmarshal(in []byte) error {
	msg := new(user.ViewGetInfoReq)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Req = msg
	return nil
}

var ViewGetInfoArgs_Req_DEFAULT *user.ViewGetInfoReq

func (p *ViewGetInfoArgs) GetReq() *user.ViewGetInfoReq {
	if !p.IsSetReq() {
		return ViewGetInfoArgs_Req_DEFAULT
	}
	return p.Req
}

func (p *ViewGetInfoArgs) IsSetReq() bool {
	return p.Req != nil
}

func (p *ViewGetInfoArgs) GetFirstArgument() interface{} {
	return p.Req
}

type ViewGetInfoResult struct {
	Success *user.ViewGetInfoResp
}

var ViewGetInfoResult_Success_DEFAULT *user.ViewGetInfoResp

func (p *ViewGetInfoResult) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetSuccess() {
		return out, nil
	}
	return proto.Marshal(p.Success)
}

func (p *ViewGetInfoResult) Unmarshal(in []byte) error {
	msg := new(user.ViewGetInfoResp)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Success = msg
	return nil
}

func (p *ViewGetInfoResult) GetSuccess() *user.ViewGetInfoResp {
	if !p.IsSetSuccess() {
		return ViewGetInfoResult_Success_DEFAULT
	}
	return p.Success
}

func (p *ViewGetInfoResult) SetSuccess(x interface{}) {
	p.Success = x.(*user.ViewGetInfoResp)
}

func (p *ViewGetInfoResult) IsSetSuccess() bool {
	return p.Success != nil
}

func (p *ViewGetInfoResult) GetResult() interface{} {
	return p.Success
}

func viewUpdateInfoHandler(ctx context.Context, handler interface{}, arg, result interface{}) error {
	switch s := arg.(type) {
	case *streaming.Args:
		st := s.Stream
		req := new(user.ViewUpdateInfoReq)
		if err := st.RecvMsg(req); err != nil {
			return err
		}
		resp, err := handler.(user.ViewService).ViewUpdateInfo(ctx, req)
		if err != nil {
			return err
		}
		return st.SendMsg(resp)
	case *ViewUpdateInfoArgs:
		success, err := handler.(user.ViewService).ViewUpdateInfo(ctx, s.Req)
		if err != nil {
			return err
		}
		realResult := result.(*ViewUpdateInfoResult)
		realResult.Success = success
		return nil
	default:
		return errInvalidMessageType
	}
}
func newViewUpdateInfoArgs() interface{} {
	return &ViewUpdateInfoArgs{}
}

func newViewUpdateInfoResult() interface{} {
	return &ViewUpdateInfoResult{}
}

type ViewUpdateInfoArgs struct {
	Req *user.ViewUpdateInfoReq
}

func (p *ViewUpdateInfoArgs) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetReq() {
		return out, nil
	}
	return proto.Marshal(p.Req)
}

func (p *ViewUpdateInfoArgs) Unmarshal(in []byte) error {
	msg := new(user.ViewUpdateInfoReq)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Req = msg
	return nil
}

var ViewUpdateInfoArgs_Req_DEFAULT *user.ViewUpdateInfoReq

func (p *ViewUpdateInfoArgs) GetReq() *user.ViewUpdateInfoReq {
	if !p.IsSetReq() {
		return ViewUpdateInfoArgs_Req_DEFAULT
	}
	return p.Req
}

func (p *ViewUpdateInfoArgs) IsSetReq() bool {
	return p.Req != nil
}

func (p *ViewUpdateInfoArgs) GetFirstArgument() interface{} {
	return p.Req
}

type ViewUpdateInfoResult struct {
	Success *basic.Response
}

var ViewUpdateInfoResult_Success_DEFAULT *basic.Response

func (p *ViewUpdateInfoResult) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetSuccess() {
		return out, nil
	}
	return proto.Marshal(p.Success)
}

func (p *ViewUpdateInfoResult) Unmarshal(in []byte) error {
	msg := new(basic.Response)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Success = msg
	return nil
}

func (p *ViewUpdateInfoResult) GetSuccess() *basic.Response {
	if !p.IsSetSuccess() {
		return ViewUpdateInfoResult_Success_DEFAULT
	}
	return p.Success
}

func (p *ViewUpdateInfoResult) SetSuccess(x interface{}) {
	p.Success = x.(*basic.Response)
}

func (p *ViewUpdateInfoResult) IsSetSuccess() bool {
	return p.Success != nil
}

func (p *ViewUpdateInfoResult) GetResult() interface{} {
	return p.Success
}

func viewUpdatePasswordHandler(ctx context.Context, handler interface{}, arg, result interface{}) error {
	switch s := arg.(type) {
	case *streaming.Args:
		st := s.Stream
		req := new(user.ViewUpdatePasswordReq)
		if err := st.RecvMsg(req); err != nil {
			return err
		}
		resp, err := handler.(user.ViewService).ViewUpdatePassword(ctx, req)
		if err != nil {
			return err
		}
		return st.SendMsg(resp)
	case *ViewUpdatePasswordArgs:
		success, err := handler.(user.ViewService).ViewUpdatePassword(ctx, s.Req)
		if err != nil {
			return err
		}
		realResult := result.(*ViewUpdatePasswordResult)
		realResult.Success = success
		return nil
	default:
		return errInvalidMessageType
	}
}
func newViewUpdatePasswordArgs() interface{} {
	return &ViewUpdatePasswordArgs{}
}

func newViewUpdatePasswordResult() interface{} {
	return &ViewUpdatePasswordResult{}
}

type ViewUpdatePasswordArgs struct {
	Req *user.ViewUpdatePasswordReq
}

func (p *ViewUpdatePasswordArgs) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetReq() {
		return out, nil
	}
	return proto.Marshal(p.Req)
}

func (p *ViewUpdatePasswordArgs) Unmarshal(in []byte) error {
	msg := new(user.ViewUpdatePasswordReq)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Req = msg
	return nil
}

var ViewUpdatePasswordArgs_Req_DEFAULT *user.ViewUpdatePasswordReq

func (p *ViewUpdatePasswordArgs) GetReq() *user.ViewUpdatePasswordReq {
	if !p.IsSetReq() {
		return ViewUpdatePasswordArgs_Req_DEFAULT
	}
	return p.Req
}

func (p *ViewUpdatePasswordArgs) IsSetReq() bool {
	return p.Req != nil
}

func (p *ViewUpdatePasswordArgs) GetFirstArgument() interface{} {
	return p.Req
}

type ViewUpdatePasswordResult struct {
	Success *basic.Response
}

var ViewUpdatePasswordResult_Success_DEFAULT *basic.Response

func (p *ViewUpdatePasswordResult) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetSuccess() {
		return out, nil
	}
	return proto.Marshal(p.Success)
}

func (p *ViewUpdatePasswordResult) Unmarshal(in []byte) error {
	msg := new(basic.Response)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Success = msg
	return nil
}

func (p *ViewUpdatePasswordResult) GetSuccess() *basic.Response {
	if !p.IsSetSuccess() {
		return ViewUpdatePasswordResult_Success_DEFAULT
	}
	return p.Success
}

func (p *ViewUpdatePasswordResult) SetSuccess(x interface{}) {
	p.Success = x.(*basic.Response)
}

func (p *ViewUpdatePasswordResult) IsSetSuccess() bool {
	return p.Success != nil
}

func (p *ViewUpdatePasswordResult) GetResult() interface{} {
	return p.Success
}

func viewBelongUnitHandler(ctx context.Context, handler interface{}, arg, result interface{}) error {
	switch s := arg.(type) {
	case *streaming.Args:
		st := s.Stream
		req := new(user.ViewBelongUnitReq)
		if err := st.RecvMsg(req); err != nil {
			return err
		}
		resp, err := handler.(user.ViewService).ViewBelongUnit(ctx, req)
		if err != nil {
			return err
		}
		return st.SendMsg(resp)
	case *ViewBelongUnitArgs:
		success, err := handler.(user.ViewService).ViewBelongUnit(ctx, s.Req)
		if err != nil {
			return err
		}
		realResult := result.(*ViewBelongUnitResult)
		realResult.Success = success
		return nil
	default:
		return errInvalidMessageType
	}
}
func newViewBelongUnitArgs() interface{} {
	return &ViewBelongUnitArgs{}
}

func newViewBelongUnitResult() interface{} {
	return &ViewBelongUnitResult{}
}

type ViewBelongUnitArgs struct {
	Req *user.ViewBelongUnitReq
}

func (p *ViewBelongUnitArgs) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetReq() {
		return out, nil
	}
	return proto.Marshal(p.Req)
}

func (p *ViewBelongUnitArgs) Unmarshal(in []byte) error {
	msg := new(user.ViewBelongUnitReq)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Req = msg
	return nil
}

var ViewBelongUnitArgs_Req_DEFAULT *user.ViewBelongUnitReq

func (p *ViewBelongUnitArgs) GetReq() *user.ViewBelongUnitReq {
	if !p.IsSetReq() {
		return ViewBelongUnitArgs_Req_DEFAULT
	}
	return p.Req
}

func (p *ViewBelongUnitArgs) IsSetReq() bool {
	return p.Req != nil
}

func (p *ViewBelongUnitArgs) GetFirstArgument() interface{} {
	return p.Req
}

type ViewBelongUnitResult struct {
	Success *user.ViewBelongUnitResp
}

var ViewBelongUnitResult_Success_DEFAULT *user.ViewBelongUnitResp

func (p *ViewBelongUnitResult) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetSuccess() {
		return out, nil
	}
	return proto.Marshal(p.Success)
}

func (p *ViewBelongUnitResult) Unmarshal(in []byte) error {
	msg := new(user.ViewBelongUnitResp)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Success = msg
	return nil
}

func (p *ViewBelongUnitResult) GetSuccess() *user.ViewBelongUnitResp {
	if !p.IsSetSuccess() {
		return ViewBelongUnitResult_Success_DEFAULT
	}
	return p.Success
}

func (p *ViewBelongUnitResult) SetSuccess(x interface{}) {
	p.Success = x.(*user.ViewBelongUnitResp)
}

func (p *ViewBelongUnitResult) IsSetSuccess() bool {
	return p.Success != nil
}

func (p *ViewBelongUnitResult) GetResult() interface{} {
	return p.Success
}

func viewSignInHandler(ctx context.Context, handler interface{}, arg, result interface{}) error {
	switch s := arg.(type) {
	case *streaming.Args:
		st := s.Stream
		req := new(user.ViewSignInReq)
		if err := st.RecvMsg(req); err != nil {
			return err
		}
		resp, err := handler.(user.ViewService).ViewSignIn(ctx, req)
		if err != nil {
			return err
		}
		return st.SendMsg(resp)
	case *ViewSignInArgs:
		success, err := handler.(user.ViewService).ViewSignIn(ctx, s.Req)
		if err != nil {
			return err
		}
		realResult := result.(*ViewSignInResult)
		realResult.Success = success
		return nil
	default:
		return errInvalidMessageType
	}
}
func newViewSignInArgs() interface{} {
	return &ViewSignInArgs{}
}

func newViewSignInResult() interface{} {
	return &ViewSignInResult{}
}

type ViewSignInArgs struct {
	Req *user.ViewSignInReq
}

func (p *ViewSignInArgs) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetReq() {
		return out, nil
	}
	return proto.Marshal(p.Req)
}

func (p *ViewSignInArgs) Unmarshal(in []byte) error {
	msg := new(user.ViewSignInReq)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Req = msg
	return nil
}

var ViewSignInArgs_Req_DEFAULT *user.ViewSignInReq

func (p *ViewSignInArgs) GetReq() *user.ViewSignInReq {
	if !p.IsSetReq() {
		return ViewSignInArgs_Req_DEFAULT
	}
	return p.Req
}

func (p *ViewSignInArgs) IsSetReq() bool {
	return p.Req != nil
}

func (p *ViewSignInArgs) GetFirstArgument() interface{} {
	return p.Req
}

type ViewSignInResult struct {
	Success *basic.Response
}

var ViewSignInResult_Success_DEFAULT *basic.Response

func (p *ViewSignInResult) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetSuccess() {
		return out, nil
	}
	return proto.Marshal(p.Success)
}

func (p *ViewSignInResult) Unmarshal(in []byte) error {
	msg := new(basic.Response)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Success = msg
	return nil
}

func (p *ViewSignInResult) GetSuccess() *basic.Response {
	if !p.IsSetSuccess() {
		return ViewSignInResult_Success_DEFAULT
	}
	return p.Success
}

func (p *ViewSignInResult) SetSuccess(x interface{}) {
	p.Success = x.(*basic.Response)
}

func (p *ViewSignInResult) IsSetSuccess() bool {
	return p.Success != nil
}

func (p *ViewSignInResult) GetResult() interface{} {
	return p.Success
}

type kClient struct {
	c client.Client
}

func newServiceClient(c client.Client) *kClient {
	return &kClient{
		c: c,
	}
}

func (p *kClient) ViewSignUp(ctx context.Context, Req *user.ViewSignUpReq) (r *basic.Response, err error) {
	var _args ViewSignUpArgs
	_args.Req = Req
	var _result ViewSignUpResult
	if err = p.c.Call(ctx, "ViewSignUp", &_args, &_result); err != nil {
		return
	}
	return _result.GetSuccess(), nil
}

func (p *kClient) ViewGetInfo(ctx context.Context, Req *user.ViewGetInfoReq) (r *user.ViewGetInfoResp, err error) {
	var _args ViewGetInfoArgs
	_args.Req = Req
	var _result ViewGetInfoResult
	if err = p.c.Call(ctx, "ViewGetInfo", &_args, &_result); err != nil {
		return
	}
	return _result.GetSuccess(), nil
}

func (p *kClient) ViewUpdateInfo(ctx context.Context, Req *user.ViewUpdateInfoReq) (r *basic.Response, err error) {
	var _args ViewUpdateInfoArgs
	_args.Req = Req
	var _result ViewUpdateInfoResult
	if err = p.c.Call(ctx, "ViewUpdateInfo", &_args, &_result); err != nil {
		return
	}
	return _result.GetSuccess(), nil
}

func (p *kClient) ViewUpdatePassword(ctx context.Context, Req *user.ViewUpdatePasswordReq) (r *basic.Response, err error) {
	var _args ViewUpdatePasswordArgs
	_args.Req = Req
	var _result ViewUpdatePasswordResult
	if err = p.c.Call(ctx, "ViewUpdatePassword", &_args, &_result); err != nil {
		return
	}
	return _result.GetSuccess(), nil
}

func (p *kClient) ViewBelongUnit(ctx context.Context, Req *user.ViewBelongUnitReq) (r *user.ViewBelongUnitResp, err error) {
	var _args ViewBelongUnitArgs
	_args.Req = Req
	var _result ViewBelongUnitResult
	if err = p.c.Call(ctx, "ViewBelongUnit", &_args, &_result); err != nil {
		return
	}
	return _result.GetSuccess(), nil
}

func (p *kClient) ViewSignIn(ctx context.Context, Req *user.ViewSignInReq) (r *basic.Response, err error) {
	var _args ViewSignInArgs
	_args.Req = Req
	var _result ViewSignInResult
	if err = p.c.Call(ctx, "ViewSignIn", &_args, &_result); err != nil {
		return
	}
	return _result.GetSuccess(), nil
}
