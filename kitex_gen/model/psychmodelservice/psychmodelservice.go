// Code generated by Kitex v0.14.1. DO NOT EDIT.

package psychmodelservice

import (
	"context"
	"errors"
	client "github.com/cloudwego/kitex/client"
	kitex "github.com/cloudwego/kitex/pkg/serviceinfo"
	streaming "github.com/cloudwego/kitex/pkg/streaming"
	proto "github.com/cloudwego/prutal"
	basic "github.com/xh-polaris/psych-idl/kitex_gen/basic"
	model "github.com/xh-polaris/psych-idl/kitex_gen/model"
)

var errInvalidMessageType = errors.New("invalid message type for service method handler")

var serviceMethods = map[string]kitex.MethodInfo{
	"UnitAppConfigCreate": kitex.NewMethodInfo(
		unitAppConfigCreateHandler,
		newUnitAppConfigCreateArgs,
		newUnitAppConfigCreateResult,
		false,
		kitex.WithStreamingMode(kitex.StreamingUnary),
	),
	"UnitAppConfigUpdate": kitex.NewMethodInfo(
		unitAppConfigUpdateHandler,
		newUnitAppConfigUpdateArgs,
		newUnitAppConfigUpdateResult,
		false,
		kitex.WithStreamingMode(kitex.StreamingUnary),
	),
	"UnitAppConfigGetById": kitex.NewMethodInfo(
		unitAppConfigGetByIdHandler,
		newUnitAppConfigGetByIdArgs,
		newUnitAppConfigGetByIdResult,
		false,
		kitex.WithStreamingMode(kitex.StreamingUnary),
	),
	"UnitAppConfigGetByUnitId": kitex.NewMethodInfo(
		unitAppConfigGetByUnitIdHandler,
		newUnitAppConfigGetByUnitIdArgs,
		newUnitAppConfigGetByUnitIdResult,
		false,
		kitex.WithStreamingMode(kitex.StreamingUnary),
	),
	"AppCreate": kitex.NewMethodInfo(
		appCreateHandler,
		newAppCreateArgs,
		newAppCreateResult,
		false,
		kitex.WithStreamingMode(kitex.StreamingUnary),
	),
	"AppUpdate": kitex.NewMethodInfo(
		appUpdateHandler,
		newAppUpdateArgs,
		newAppUpdateResult,
		false,
		kitex.WithStreamingMode(kitex.StreamingUnary),
	),
	"AppGetByUnitId": kitex.NewMethodInfo(
		appGetByUnitIdHandler,
		newAppGetByUnitIdArgs,
		newAppGetByUnitIdResult,
		false,
		kitex.WithStreamingMode(kitex.StreamingUnary),
	),
	"AppGetPages": kitex.NewMethodInfo(
		appGetPagesHandler,
		newAppGetPagesArgs,
		newAppGetPagesResult,
		false,
		kitex.WithStreamingMode(kitex.StreamingUnary),
	),
	"AppDelete": kitex.NewMethodInfo(
		appDeleteHandler,
		newAppDeleteArgs,
		newAppDeleteResult,
		false,
		kitex.WithStreamingMode(kitex.StreamingUnary),
	),
}

var (
	psychModelServiceServiceInfo                = NewServiceInfo()
	psychModelServiceServiceInfoForClient       = NewServiceInfoForClient()
	psychModelServiceServiceInfoForStreamClient = NewServiceInfoForStreamClient()
)

// for server
func serviceInfo() *kitex.ServiceInfo {
	return psychModelServiceServiceInfo
}

// for stream client
func serviceInfoForStreamClient() *kitex.ServiceInfo {
	return psychModelServiceServiceInfoForStreamClient
}

// for client
func serviceInfoForClient() *kitex.ServiceInfo {
	return psychModelServiceServiceInfoForClient
}

// NewServiceInfo creates a new ServiceInfo containing all methods
func NewServiceInfo() *kitex.ServiceInfo {
	return newServiceInfo(false, true, true)
}

// NewServiceInfo creates a new ServiceInfo containing non-streaming methods
func NewServiceInfoForClient() *kitex.ServiceInfo {
	return newServiceInfo(false, false, true)
}
func NewServiceInfoForStreamClient() *kitex.ServiceInfo {
	return newServiceInfo(true, true, false)
}

func newServiceInfo(hasStreaming bool, keepStreamingMethods bool, keepNonStreamingMethods bool) *kitex.ServiceInfo {
	serviceName := "PsychModelService"
	handlerType := (*model.PsychModelService)(nil)
	methods := map[string]kitex.MethodInfo{}
	for name, m := range serviceMethods {
		if m.IsStreaming() && !keepStreamingMethods {
			continue
		}
		if !m.IsStreaming() && !keepNonStreamingMethods {
			continue
		}
		methods[name] = m
	}
	extra := map[string]interface{}{
		"PackageName": "model",
	}
	if hasStreaming {
		extra["streaming"] = hasStreaming
	}
	svcInfo := &kitex.ServiceInfo{
		ServiceName:     serviceName,
		HandlerType:     handlerType,
		Methods:         methods,
		PayloadCodec:    kitex.Protobuf,
		KiteXGenVersion: "v0.14.1",
		Extra:           extra,
	}
	return svcInfo
}

func unitAppConfigCreateHandler(ctx context.Context, handler interface{}, arg, result interface{}) error {
	switch s := arg.(type) {
	case *streaming.Args:
		st := s.Stream
		req := new(model.UnitAppConfigCreateReq)
		if err := st.RecvMsg(req); err != nil {
			return err
		}
		resp, err := handler.(model.PsychModelService).UnitAppConfigCreate(ctx, req)
		if err != nil {
			return err
		}
		return st.SendMsg(resp)
	case *UnitAppConfigCreateArgs:
		success, err := handler.(model.PsychModelService).UnitAppConfigCreate(ctx, s.Req)
		if err != nil {
			return err
		}
		realResult := result.(*UnitAppConfigCreateResult)
		realResult.Success = success
		return nil
	default:
		return errInvalidMessageType
	}
}
func newUnitAppConfigCreateArgs() interface{} {
	return &UnitAppConfigCreateArgs{}
}

func newUnitAppConfigCreateResult() interface{} {
	return &UnitAppConfigCreateResult{}
}

type UnitAppConfigCreateArgs struct {
	Req *model.UnitAppConfigCreateReq
}

func (p *UnitAppConfigCreateArgs) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetReq() {
		return out, nil
	}
	return proto.Marshal(p.Req)
}

func (p *UnitAppConfigCreateArgs) Unmarshal(in []byte) error {
	msg := new(model.UnitAppConfigCreateReq)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Req = msg
	return nil
}

var UnitAppConfigCreateArgs_Req_DEFAULT *model.UnitAppConfigCreateReq

func (p *UnitAppConfigCreateArgs) GetReq() *model.UnitAppConfigCreateReq {
	if !p.IsSetReq() {
		return UnitAppConfigCreateArgs_Req_DEFAULT
	}
	return p.Req
}

func (p *UnitAppConfigCreateArgs) IsSetReq() bool {
	return p.Req != nil
}

func (p *UnitAppConfigCreateArgs) GetFirstArgument() interface{} {
	return p.Req
}

type UnitAppConfigCreateResult struct {
	Success *model.UnitAppConfigCreateResp
}

var UnitAppConfigCreateResult_Success_DEFAULT *model.UnitAppConfigCreateResp

func (p *UnitAppConfigCreateResult) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetSuccess() {
		return out, nil
	}
	return proto.Marshal(p.Success)
}

func (p *UnitAppConfigCreateResult) Unmarshal(in []byte) error {
	msg := new(model.UnitAppConfigCreateResp)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Success = msg
	return nil
}

func (p *UnitAppConfigCreateResult) GetSuccess() *model.UnitAppConfigCreateResp {
	if !p.IsSetSuccess() {
		return UnitAppConfigCreateResult_Success_DEFAULT
	}
	return p.Success
}

func (p *UnitAppConfigCreateResult) SetSuccess(x interface{}) {
	p.Success = x.(*model.UnitAppConfigCreateResp)
}

func (p *UnitAppConfigCreateResult) IsSetSuccess() bool {
	return p.Success != nil
}

func (p *UnitAppConfigCreateResult) GetResult() interface{} {
	return p.Success
}

func unitAppConfigUpdateHandler(ctx context.Context, handler interface{}, arg, result interface{}) error {
	switch s := arg.(type) {
	case *streaming.Args:
		st := s.Stream
		req := new(model.UnitAppConfigUpdateReq)
		if err := st.RecvMsg(req); err != nil {
			return err
		}
		resp, err := handler.(model.PsychModelService).UnitAppConfigUpdate(ctx, req)
		if err != nil {
			return err
		}
		return st.SendMsg(resp)
	case *UnitAppConfigUpdateArgs:
		success, err := handler.(model.PsychModelService).UnitAppConfigUpdate(ctx, s.Req)
		if err != nil {
			return err
		}
		realResult := result.(*UnitAppConfigUpdateResult)
		realResult.Success = success
		return nil
	default:
		return errInvalidMessageType
	}
}
func newUnitAppConfigUpdateArgs() interface{} {
	return &UnitAppConfigUpdateArgs{}
}

func newUnitAppConfigUpdateResult() interface{} {
	return &UnitAppConfigUpdateResult{}
}

type UnitAppConfigUpdateArgs struct {
	Req *model.UnitAppConfigUpdateReq
}

func (p *UnitAppConfigUpdateArgs) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetReq() {
		return out, nil
	}
	return proto.Marshal(p.Req)
}

func (p *UnitAppConfigUpdateArgs) Unmarshal(in []byte) error {
	msg := new(model.UnitAppConfigUpdateReq)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Req = msg
	return nil
}

var UnitAppConfigUpdateArgs_Req_DEFAULT *model.UnitAppConfigUpdateReq

func (p *UnitAppConfigUpdateArgs) GetReq() *model.UnitAppConfigUpdateReq {
	if !p.IsSetReq() {
		return UnitAppConfigUpdateArgs_Req_DEFAULT
	}
	return p.Req
}

func (p *UnitAppConfigUpdateArgs) IsSetReq() bool {
	return p.Req != nil
}

func (p *UnitAppConfigUpdateArgs) GetFirstArgument() interface{} {
	return p.Req
}

type UnitAppConfigUpdateResult struct {
	Success *basic.Response
}

var UnitAppConfigUpdateResult_Success_DEFAULT *basic.Response

func (p *UnitAppConfigUpdateResult) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetSuccess() {
		return out, nil
	}
	return proto.Marshal(p.Success)
}

func (p *UnitAppConfigUpdateResult) Unmarshal(in []byte) error {
	msg := new(basic.Response)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Success = msg
	return nil
}

func (p *UnitAppConfigUpdateResult) GetSuccess() *basic.Response {
	if !p.IsSetSuccess() {
		return UnitAppConfigUpdateResult_Success_DEFAULT
	}
	return p.Success
}

func (p *UnitAppConfigUpdateResult) SetSuccess(x interface{}) {
	p.Success = x.(*basic.Response)
}

func (p *UnitAppConfigUpdateResult) IsSetSuccess() bool {
	return p.Success != nil
}

func (p *UnitAppConfigUpdateResult) GetResult() interface{} {
	return p.Success
}

func unitAppConfigGetByIdHandler(ctx context.Context, handler interface{}, arg, result interface{}) error {
	switch s := arg.(type) {
	case *streaming.Args:
		st := s.Stream
		req := new(model.UnitAppConfigGetByIdReq)
		if err := st.RecvMsg(req); err != nil {
			return err
		}
		resp, err := handler.(model.PsychModelService).UnitAppConfigGetById(ctx, req)
		if err != nil {
			return err
		}
		return st.SendMsg(resp)
	case *UnitAppConfigGetByIdArgs:
		success, err := handler.(model.PsychModelService).UnitAppConfigGetById(ctx, s.Req)
		if err != nil {
			return err
		}
		realResult := result.(*UnitAppConfigGetByIdResult)
		realResult.Success = success
		return nil
	default:
		return errInvalidMessageType
	}
}
func newUnitAppConfigGetByIdArgs() interface{} {
	return &UnitAppConfigGetByIdArgs{}
}

func newUnitAppConfigGetByIdResult() interface{} {
	return &UnitAppConfigGetByIdResult{}
}

type UnitAppConfigGetByIdArgs struct {
	Req *model.UnitAppConfigGetByIdReq
}

func (p *UnitAppConfigGetByIdArgs) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetReq() {
		return out, nil
	}
	return proto.Marshal(p.Req)
}

func (p *UnitAppConfigGetByIdArgs) Unmarshal(in []byte) error {
	msg := new(model.UnitAppConfigGetByIdReq)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Req = msg
	return nil
}

var UnitAppConfigGetByIdArgs_Req_DEFAULT *model.UnitAppConfigGetByIdReq

func (p *UnitAppConfigGetByIdArgs) GetReq() *model.UnitAppConfigGetByIdReq {
	if !p.IsSetReq() {
		return UnitAppConfigGetByIdArgs_Req_DEFAULT
	}
	return p.Req
}

func (p *UnitAppConfigGetByIdArgs) IsSetReq() bool {
	return p.Req != nil
}

func (p *UnitAppConfigGetByIdArgs) GetFirstArgument() interface{} {
	return p.Req
}

type UnitAppConfigGetByIdResult struct {
	Success *model.UnitAppConfigGetByIdResp
}

var UnitAppConfigGetByIdResult_Success_DEFAULT *model.UnitAppConfigGetByIdResp

func (p *UnitAppConfigGetByIdResult) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetSuccess() {
		return out, nil
	}
	return proto.Marshal(p.Success)
}

func (p *UnitAppConfigGetByIdResult) Unmarshal(in []byte) error {
	msg := new(model.UnitAppConfigGetByIdResp)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Success = msg
	return nil
}

func (p *UnitAppConfigGetByIdResult) GetSuccess() *model.UnitAppConfigGetByIdResp {
	if !p.IsSetSuccess() {
		return UnitAppConfigGetByIdResult_Success_DEFAULT
	}
	return p.Success
}

func (p *UnitAppConfigGetByIdResult) SetSuccess(x interface{}) {
	p.Success = x.(*model.UnitAppConfigGetByIdResp)
}

func (p *UnitAppConfigGetByIdResult) IsSetSuccess() bool {
	return p.Success != nil
}

func (p *UnitAppConfigGetByIdResult) GetResult() interface{} {
	return p.Success
}

func unitAppConfigGetByUnitIdHandler(ctx context.Context, handler interface{}, arg, result interface{}) error {
	switch s := arg.(type) {
	case *streaming.Args:
		st := s.Stream
		req := new(model.UnitAppConfigGetByUnitIdReq)
		if err := st.RecvMsg(req); err != nil {
			return err
		}
		resp, err := handler.(model.PsychModelService).UnitAppConfigGetByUnitId(ctx, req)
		if err != nil {
			return err
		}
		return st.SendMsg(resp)
	case *UnitAppConfigGetByUnitIdArgs:
		success, err := handler.(model.PsychModelService).UnitAppConfigGetByUnitId(ctx, s.Req)
		if err != nil {
			return err
		}
		realResult := result.(*UnitAppConfigGetByUnitIdResult)
		realResult.Success = success
		return nil
	default:
		return errInvalidMessageType
	}
}
func newUnitAppConfigGetByUnitIdArgs() interface{} {
	return &UnitAppConfigGetByUnitIdArgs{}
}

func newUnitAppConfigGetByUnitIdResult() interface{} {
	return &UnitAppConfigGetByUnitIdResult{}
}

type UnitAppConfigGetByUnitIdArgs struct {
	Req *model.UnitAppConfigGetByUnitIdReq
}

func (p *UnitAppConfigGetByUnitIdArgs) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetReq() {
		return out, nil
	}
	return proto.Marshal(p.Req)
}

func (p *UnitAppConfigGetByUnitIdArgs) Unmarshal(in []byte) error {
	msg := new(model.UnitAppConfigGetByUnitIdReq)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Req = msg
	return nil
}

var UnitAppConfigGetByUnitIdArgs_Req_DEFAULT *model.UnitAppConfigGetByUnitIdReq

func (p *UnitAppConfigGetByUnitIdArgs) GetReq() *model.UnitAppConfigGetByUnitIdReq {
	if !p.IsSetReq() {
		return UnitAppConfigGetByUnitIdArgs_Req_DEFAULT
	}
	return p.Req
}

func (p *UnitAppConfigGetByUnitIdArgs) IsSetReq() bool {
	return p.Req != nil
}

func (p *UnitAppConfigGetByUnitIdArgs) GetFirstArgument() interface{} {
	return p.Req
}

type UnitAppConfigGetByUnitIdResult struct {
	Success *model.UnitAppConfigGetByUnitIdResp
}

var UnitAppConfigGetByUnitIdResult_Success_DEFAULT *model.UnitAppConfigGetByUnitIdResp

func (p *UnitAppConfigGetByUnitIdResult) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetSuccess() {
		return out, nil
	}
	return proto.Marshal(p.Success)
}

func (p *UnitAppConfigGetByUnitIdResult) Unmarshal(in []byte) error {
	msg := new(model.UnitAppConfigGetByUnitIdResp)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Success = msg
	return nil
}

func (p *UnitAppConfigGetByUnitIdResult) GetSuccess() *model.UnitAppConfigGetByUnitIdResp {
	if !p.IsSetSuccess() {
		return UnitAppConfigGetByUnitIdResult_Success_DEFAULT
	}
	return p.Success
}

func (p *UnitAppConfigGetByUnitIdResult) SetSuccess(x interface{}) {
	p.Success = x.(*model.UnitAppConfigGetByUnitIdResp)
}

func (p *UnitAppConfigGetByUnitIdResult) IsSetSuccess() bool {
	return p.Success != nil
}

func (p *UnitAppConfigGetByUnitIdResult) GetResult() interface{} {
	return p.Success
}

func appCreateHandler(ctx context.Context, handler interface{}, arg, result interface{}) error {
	switch s := arg.(type) {
	case *streaming.Args:
		st := s.Stream
		req := new(model.AppCreateReq)
		if err := st.RecvMsg(req); err != nil {
			return err
		}
		resp, err := handler.(model.PsychModelService).AppCreate(ctx, req)
		if err != nil {
			return err
		}
		return st.SendMsg(resp)
	case *AppCreateArgs:
		success, err := handler.(model.PsychModelService).AppCreate(ctx, s.Req)
		if err != nil {
			return err
		}
		realResult := result.(*AppCreateResult)
		realResult.Success = success
		return nil
	default:
		return errInvalidMessageType
	}
}
func newAppCreateArgs() interface{} {
	return &AppCreateArgs{}
}

func newAppCreateResult() interface{} {
	return &AppCreateResult{}
}

type AppCreateArgs struct {
	Req *model.AppCreateReq
}

func (p *AppCreateArgs) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetReq() {
		return out, nil
	}
	return proto.Marshal(p.Req)
}

func (p *AppCreateArgs) Unmarshal(in []byte) error {
	msg := new(model.AppCreateReq)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Req = msg
	return nil
}

var AppCreateArgs_Req_DEFAULT *model.AppCreateReq

func (p *AppCreateArgs) GetReq() *model.AppCreateReq {
	if !p.IsSetReq() {
		return AppCreateArgs_Req_DEFAULT
	}
	return p.Req
}

func (p *AppCreateArgs) IsSetReq() bool {
	return p.Req != nil
}

func (p *AppCreateArgs) GetFirstArgument() interface{} {
	return p.Req
}

type AppCreateResult struct {
	Success *model.AppCreateResp
}

var AppCreateResult_Success_DEFAULT *model.AppCreateResp

func (p *AppCreateResult) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetSuccess() {
		return out, nil
	}
	return proto.Marshal(p.Success)
}

func (p *AppCreateResult) Unmarshal(in []byte) error {
	msg := new(model.AppCreateResp)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Success = msg
	return nil
}

func (p *AppCreateResult) GetSuccess() *model.AppCreateResp {
	if !p.IsSetSuccess() {
		return AppCreateResult_Success_DEFAULT
	}
	return p.Success
}

func (p *AppCreateResult) SetSuccess(x interface{}) {
	p.Success = x.(*model.AppCreateResp)
}

func (p *AppCreateResult) IsSetSuccess() bool {
	return p.Success != nil
}

func (p *AppCreateResult) GetResult() interface{} {
	return p.Success
}

func appUpdateHandler(ctx context.Context, handler interface{}, arg, result interface{}) error {
	switch s := arg.(type) {
	case *streaming.Args:
		st := s.Stream
		req := new(model.AppUpdateReq)
		if err := st.RecvMsg(req); err != nil {
			return err
		}
		resp, err := handler.(model.PsychModelService).AppUpdate(ctx, req)
		if err != nil {
			return err
		}
		return st.SendMsg(resp)
	case *AppUpdateArgs:
		success, err := handler.(model.PsychModelService).AppUpdate(ctx, s.Req)
		if err != nil {
			return err
		}
		realResult := result.(*AppUpdateResult)
		realResult.Success = success
		return nil
	default:
		return errInvalidMessageType
	}
}
func newAppUpdateArgs() interface{} {
	return &AppUpdateArgs{}
}

func newAppUpdateResult() interface{} {
	return &AppUpdateResult{}
}

type AppUpdateArgs struct {
	Req *model.AppUpdateReq
}

func (p *AppUpdateArgs) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetReq() {
		return out, nil
	}
	return proto.Marshal(p.Req)
}

func (p *AppUpdateArgs) Unmarshal(in []byte) error {
	msg := new(model.AppUpdateReq)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Req = msg
	return nil
}

var AppUpdateArgs_Req_DEFAULT *model.AppUpdateReq

func (p *AppUpdateArgs) GetReq() *model.AppUpdateReq {
	if !p.IsSetReq() {
		return AppUpdateArgs_Req_DEFAULT
	}
	return p.Req
}

func (p *AppUpdateArgs) IsSetReq() bool {
	return p.Req != nil
}

func (p *AppUpdateArgs) GetFirstArgument() interface{} {
	return p.Req
}

type AppUpdateResult struct {
	Success *basic.Response
}

var AppUpdateResult_Success_DEFAULT *basic.Response

func (p *AppUpdateResult) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetSuccess() {
		return out, nil
	}
	return proto.Marshal(p.Success)
}

func (p *AppUpdateResult) Unmarshal(in []byte) error {
	msg := new(basic.Response)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Success = msg
	return nil
}

func (p *AppUpdateResult) GetSuccess() *basic.Response {
	if !p.IsSetSuccess() {
		return AppUpdateResult_Success_DEFAULT
	}
	return p.Success
}

func (p *AppUpdateResult) SetSuccess(x interface{}) {
	p.Success = x.(*basic.Response)
}

func (p *AppUpdateResult) IsSetSuccess() bool {
	return p.Success != nil
}

func (p *AppUpdateResult) GetResult() interface{} {
	return p.Success
}

func appGetByUnitIdHandler(ctx context.Context, handler interface{}, arg, result interface{}) error {
	switch s := arg.(type) {
	case *streaming.Args:
		st := s.Stream
		req := new(model.AppGetByUnitIdReq)
		if err := st.RecvMsg(req); err != nil {
			return err
		}
		resp, err := handler.(model.PsychModelService).AppGetByUnitId(ctx, req)
		if err != nil {
			return err
		}
		return st.SendMsg(resp)
	case *AppGetByUnitIdArgs:
		success, err := handler.(model.PsychModelService).AppGetByUnitId(ctx, s.Req)
		if err != nil {
			return err
		}
		realResult := result.(*AppGetByUnitIdResult)
		realResult.Success = success
		return nil
	default:
		return errInvalidMessageType
	}
}
func newAppGetByUnitIdArgs() interface{} {
	return &AppGetByUnitIdArgs{}
}

func newAppGetByUnitIdResult() interface{} {
	return &AppGetByUnitIdResult{}
}

type AppGetByUnitIdArgs struct {
	Req *model.AppGetByUnitIdReq
}

func (p *AppGetByUnitIdArgs) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetReq() {
		return out, nil
	}
	return proto.Marshal(p.Req)
}

func (p *AppGetByUnitIdArgs) Unmarshal(in []byte) error {
	msg := new(model.AppGetByUnitIdReq)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Req = msg
	return nil
}

var AppGetByUnitIdArgs_Req_DEFAULT *model.AppGetByUnitIdReq

func (p *AppGetByUnitIdArgs) GetReq() *model.AppGetByUnitIdReq {
	if !p.IsSetReq() {
		return AppGetByUnitIdArgs_Req_DEFAULT
	}
	return p.Req
}

func (p *AppGetByUnitIdArgs) IsSetReq() bool {
	return p.Req != nil
}

func (p *AppGetByUnitIdArgs) GetFirstArgument() interface{} {
	return p.Req
}

type AppGetByUnitIdResult struct {
	Success *model.AppGetByUnitIdResp
}

var AppGetByUnitIdResult_Success_DEFAULT *model.AppGetByUnitIdResp

func (p *AppGetByUnitIdResult) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetSuccess() {
		return out, nil
	}
	return proto.Marshal(p.Success)
}

func (p *AppGetByUnitIdResult) Unmarshal(in []byte) error {
	msg := new(model.AppGetByUnitIdResp)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Success = msg
	return nil
}

func (p *AppGetByUnitIdResult) GetSuccess() *model.AppGetByUnitIdResp {
	if !p.IsSetSuccess() {
		return AppGetByUnitIdResult_Success_DEFAULT
	}
	return p.Success
}

func (p *AppGetByUnitIdResult) SetSuccess(x interface{}) {
	p.Success = x.(*model.AppGetByUnitIdResp)
}

func (p *AppGetByUnitIdResult) IsSetSuccess() bool {
	return p.Success != nil
}

func (p *AppGetByUnitIdResult) GetResult() interface{} {
	return p.Success
}

func appGetPagesHandler(ctx context.Context, handler interface{}, arg, result interface{}) error {
	switch s := arg.(type) {
	case *streaming.Args:
		st := s.Stream
		req := new(model.AppGetPagesReq)
		if err := st.RecvMsg(req); err != nil {
			return err
		}
		resp, err := handler.(model.PsychModelService).AppGetPages(ctx, req)
		if err != nil {
			return err
		}
		return st.SendMsg(resp)
	case *AppGetPagesArgs:
		success, err := handler.(model.PsychModelService).AppGetPages(ctx, s.Req)
		if err != nil {
			return err
		}
		realResult := result.(*AppGetPagesResult)
		realResult.Success = success
		return nil
	default:
		return errInvalidMessageType
	}
}
func newAppGetPagesArgs() interface{} {
	return &AppGetPagesArgs{}
}

func newAppGetPagesResult() interface{} {
	return &AppGetPagesResult{}
}

type AppGetPagesArgs struct {
	Req *model.AppGetPagesReq
}

func (p *AppGetPagesArgs) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetReq() {
		return out, nil
	}
	return proto.Marshal(p.Req)
}

func (p *AppGetPagesArgs) Unmarshal(in []byte) error {
	msg := new(model.AppGetPagesReq)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Req = msg
	return nil
}

var AppGetPagesArgs_Req_DEFAULT *model.AppGetPagesReq

func (p *AppGetPagesArgs) GetReq() *model.AppGetPagesReq {
	if !p.IsSetReq() {
		return AppGetPagesArgs_Req_DEFAULT
	}
	return p.Req
}

func (p *AppGetPagesArgs) IsSetReq() bool {
	return p.Req != nil
}

func (p *AppGetPagesArgs) GetFirstArgument() interface{} {
	return p.Req
}

type AppGetPagesResult struct {
	Success *model.AppGetPagesResp
}

var AppGetPagesResult_Success_DEFAULT *model.AppGetPagesResp

func (p *AppGetPagesResult) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetSuccess() {
		return out, nil
	}
	return proto.Marshal(p.Success)
}

func (p *AppGetPagesResult) Unmarshal(in []byte) error {
	msg := new(model.AppGetPagesResp)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Success = msg
	return nil
}

func (p *AppGetPagesResult) GetSuccess() *model.AppGetPagesResp {
	if !p.IsSetSuccess() {
		return AppGetPagesResult_Success_DEFAULT
	}
	return p.Success
}

func (p *AppGetPagesResult) SetSuccess(x interface{}) {
	p.Success = x.(*model.AppGetPagesResp)
}

func (p *AppGetPagesResult) IsSetSuccess() bool {
	return p.Success != nil
}

func (p *AppGetPagesResult) GetResult() interface{} {
	return p.Success
}

func appDeleteHandler(ctx context.Context, handler interface{}, arg, result interface{}) error {
	switch s := arg.(type) {
	case *streaming.Args:
		st := s.Stream
		req := new(model.AppDeleteReq)
		if err := st.RecvMsg(req); err != nil {
			return err
		}
		resp, err := handler.(model.PsychModelService).AppDelete(ctx, req)
		if err != nil {
			return err
		}
		return st.SendMsg(resp)
	case *AppDeleteArgs:
		success, err := handler.(model.PsychModelService).AppDelete(ctx, s.Req)
		if err != nil {
			return err
		}
		realResult := result.(*AppDeleteResult)
		realResult.Success = success
		return nil
	default:
		return errInvalidMessageType
	}
}
func newAppDeleteArgs() interface{} {
	return &AppDeleteArgs{}
}

func newAppDeleteResult() interface{} {
	return &AppDeleteResult{}
}

type AppDeleteArgs struct {
	Req *model.AppDeleteReq
}

func (p *AppDeleteArgs) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetReq() {
		return out, nil
	}
	return proto.Marshal(p.Req)
}

func (p *AppDeleteArgs) Unmarshal(in []byte) error {
	msg := new(model.AppDeleteReq)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Req = msg
	return nil
}

var AppDeleteArgs_Req_DEFAULT *model.AppDeleteReq

func (p *AppDeleteArgs) GetReq() *model.AppDeleteReq {
	if !p.IsSetReq() {
		return AppDeleteArgs_Req_DEFAULT
	}
	return p.Req
}

func (p *AppDeleteArgs) IsSetReq() bool {
	return p.Req != nil
}

func (p *AppDeleteArgs) GetFirstArgument() interface{} {
	return p.Req
}

type AppDeleteResult struct {
	Success *basic.Response
}

var AppDeleteResult_Success_DEFAULT *basic.Response

func (p *AppDeleteResult) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetSuccess() {
		return out, nil
	}
	return proto.Marshal(p.Success)
}

func (p *AppDeleteResult) Unmarshal(in []byte) error {
	msg := new(basic.Response)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Success = msg
	return nil
}

func (p *AppDeleteResult) GetSuccess() *basic.Response {
	if !p.IsSetSuccess() {
		return AppDeleteResult_Success_DEFAULT
	}
	return p.Success
}

func (p *AppDeleteResult) SetSuccess(x interface{}) {
	p.Success = x.(*basic.Response)
}

func (p *AppDeleteResult) IsSetSuccess() bool {
	return p.Success != nil
}

func (p *AppDeleteResult) GetResult() interface{} {
	return p.Success
}

type kClient struct {
	c client.Client
}

func newServiceClient(c client.Client) *kClient {
	return &kClient{
		c: c,
	}
}

func (p *kClient) UnitAppConfigCreate(ctx context.Context, Req *model.UnitAppConfigCreateReq) (r *model.UnitAppConfigCreateResp, err error) {
	var _args UnitAppConfigCreateArgs
	_args.Req = Req
	var _result UnitAppConfigCreateResult
	if err = p.c.Call(ctx, "UnitAppConfigCreate", &_args, &_result); err != nil {
		return
	}
	return _result.GetSuccess(), nil
}

func (p *kClient) UnitAppConfigUpdate(ctx context.Context, Req *model.UnitAppConfigUpdateReq) (r *basic.Response, err error) {
	var _args UnitAppConfigUpdateArgs
	_args.Req = Req
	var _result UnitAppConfigUpdateResult
	if err = p.c.Call(ctx, "UnitAppConfigUpdate", &_args, &_result); err != nil {
		return
	}
	return _result.GetSuccess(), nil
}

func (p *kClient) UnitAppConfigGetById(ctx context.Context, Req *model.UnitAppConfigGetByIdReq) (r *model.UnitAppConfigGetByIdResp, err error) {
	var _args UnitAppConfigGetByIdArgs
	_args.Req = Req
	var _result UnitAppConfigGetByIdResult
	if err = p.c.Call(ctx, "UnitAppConfigGetById", &_args, &_result); err != nil {
		return
	}
	return _result.GetSuccess(), nil
}

func (p *kClient) UnitAppConfigGetByUnitId(ctx context.Context, Req *model.UnitAppConfigGetByUnitIdReq) (r *model.UnitAppConfigGetByUnitIdResp, err error) {
	var _args UnitAppConfigGetByUnitIdArgs
	_args.Req = Req
	var _result UnitAppConfigGetByUnitIdResult
	if err = p.c.Call(ctx, "UnitAppConfigGetByUnitId", &_args, &_result); err != nil {
		return
	}
	return _result.GetSuccess(), nil
}

func (p *kClient) AppCreate(ctx context.Context, Req *model.AppCreateReq) (r *model.AppCreateResp, err error) {
	var _args AppCreateArgs
	_args.Req = Req
	var _result AppCreateResult
	if err = p.c.Call(ctx, "AppCreate", &_args, &_result); err != nil {
		return
	}
	return _result.GetSuccess(), nil
}

func (p *kClient) AppUpdate(ctx context.Context, Req *model.AppUpdateReq) (r *basic.Response, err error) {
	var _args AppUpdateArgs
	_args.Req = Req
	var _result AppUpdateResult
	if err = p.c.Call(ctx, "AppUpdate", &_args, &_result); err != nil {
		return
	}
	return _result.GetSuccess(), nil
}

func (p *kClient) AppGetByUnitId(ctx context.Context, Req *model.AppGetByUnitIdReq) (r *model.AppGetByUnitIdResp, err error) {
	var _args AppGetByUnitIdArgs
	_args.Req = Req
	var _result AppGetByUnitIdResult
	if err = p.c.Call(ctx, "AppGetByUnitId", &_args, &_result); err != nil {
		return
	}
	return _result.GetSuccess(), nil
}

func (p *kClient) AppGetPages(ctx context.Context, Req *model.AppGetPagesReq) (r *model.AppGetPagesResp, err error) {
	var _args AppGetPagesArgs
	_args.Req = Req
	var _result AppGetPagesResult
	if err = p.c.Call(ctx, "AppGetPages", &_args, &_result); err != nil {
		return
	}
	return _result.GetSuccess(), nil
}

func (p *kClient) AppDelete(ctx context.Context, Req *model.AppDeleteReq) (r *basic.Response, err error) {
	var _args AppDeleteArgs
	_args.Req = Req
	var _result AppDeleteResult
	if err = p.c.Call(ctx, "AppDelete", &_args, &_result); err != nil {
		return
	}
	return _result.GetSuccess(), nil
}
