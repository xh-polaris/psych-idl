// Code generated by Kitex v0.16.0. DO NOT EDIT.

package psychmodelservice

import (
	"context"
	"errors"
	client "github.com/cloudwego/kitex/client"
	kitex "github.com/cloudwego/kitex/pkg/serviceinfo"
	streaming "github.com/cloudwego/kitex/pkg/streaming"
	proto "github.com/cloudwego/prutal"
	basic "github.com/xh-polaris/psych-idl/kitex_gen/basic"
	model "github.com/xh-polaris/psych-idl/kitex_gen/model"
)

var errInvalidMessageType = errors.New("invalid message type for service method handler")

var serviceMethods = map[string]kitex.MethodInfo{
	"UnitAppConfigCreate": kitex.NewMethodInfo(
		unitAppConfigCreateHandler,
		newUnitAppConfigCreateArgs,
		newUnitAppConfigCreateResult,
		false,
		kitex.WithStreamingMode(kitex.StreamingUnary),
	),
	"UnitAppConfigUpdate": kitex.NewMethodInfo(
		unitAppConfigUpdateHandler,
		newUnitAppConfigUpdateArgs,
		newUnitAppConfigUpdateResult,
		false,
		kitex.WithStreamingMode(kitex.StreamingUnary),
	),
	"UnitAppConfigGetById": kitex.NewMethodInfo(
		unitAppConfigGetByIdHandler,
		newUnitAppConfigGetByIdArgs,
		newUnitAppConfigGetByIdResult,
		false,
		kitex.WithStreamingMode(kitex.StreamingUnary),
	),
	"UnitAppConfigGetByUnitId": kitex.NewMethodInfo(
		unitAppConfigGetByUnitIdHandler,
		newUnitAppConfigGetByUnitIdArgs,
		newUnitAppConfigGetByUnitIdResult,
		false,
		kitex.WithStreamingMode(kitex.StreamingUnary),
	),
	"AppCreate": kitex.NewMethodInfo(
		appCreateHandler,
		newAppCreateArgs,
		newAppCreateResult,
		false,
		kitex.WithStreamingMode(kitex.StreamingUnary),
	),
	"AppUpdate": kitex.NewMethodInfo(
		appUpdateHandler,
		newAppUpdateArgs,
		newAppUpdateResult,
		false,
		kitex.WithStreamingMode(kitex.StreamingUnary),
	),
	"AppGetById": kitex.NewMethodInfo(
		appGetByIdHandler,
		newAppGetByIdArgs,
		newAppGetByIdResult,
		false,
		kitex.WithStreamingMode(kitex.StreamingUnary),
	),
	"AppGetByConfigId": kitex.NewMethodInfo(
		appGetByConfigIdHandler,
		newAppGetByConfigIdArgs,
		newAppGetByConfigIdResult,
		false,
		kitex.WithStreamingMode(kitex.StreamingUnary),
	),
	"AppList": kitex.NewMethodInfo(
		appListHandler,
		newAppListArgs,
		newAppListResult,
		false,
		kitex.WithStreamingMode(kitex.StreamingUnary),
	),
	"AppDelete": kitex.NewMethodInfo(
		appDeleteHandler,
		newAppDeleteArgs,
		newAppDeleteResult,
		false,
		kitex.WithStreamingMode(kitex.StreamingUnary),
	),
}

var (
	psychModelServiceServiceInfo                = NewServiceInfo()
	psychModelServiceServiceInfoForClient       = NewServiceInfoForClient()
	psychModelServiceServiceInfoForStreamClient = NewServiceInfoForStreamClient()
)

// for server
func serviceInfo() *kitex.ServiceInfo {
	return psychModelServiceServiceInfo
}

// for stream client
func serviceInfoForStreamClient() *kitex.ServiceInfo {
	return psychModelServiceServiceInfoForStreamClient
}

// for client
func serviceInfoForClient() *kitex.ServiceInfo {
	return psychModelServiceServiceInfoForClient
}

// NewServiceInfo creates a new ServiceInfo containing all methods
func NewServiceInfo() *kitex.ServiceInfo {
	return newServiceInfo(false, true, true)
}

// NewServiceInfo creates a new ServiceInfo containing non-streaming methods
func NewServiceInfoForClient() *kitex.ServiceInfo {
	return newServiceInfo(false, false, true)
}
func NewServiceInfoForStreamClient() *kitex.ServiceInfo {
	return newServiceInfo(true, true, false)
}

func newServiceInfo(hasStreaming bool, keepStreamingMethods bool, keepNonStreamingMethods bool) *kitex.ServiceInfo {
	serviceName := "PsychModelService"
	handlerType := (*model.PsychModelService)(nil)
	methods := map[string]kitex.MethodInfo{}
	for name, m := range serviceMethods {
		if m.IsStreaming() && !keepStreamingMethods {
			continue
		}
		if !m.IsStreaming() && !keepNonStreamingMethods {
			continue
		}
		methods[name] = m
	}
	extra := map[string]interface{}{
		"PackageName": "model",
	}
	if hasStreaming {
		extra["streaming"] = hasStreaming
	}
	svcInfo := &kitex.ServiceInfo{
		ServiceName:     serviceName,
		HandlerType:     handlerType,
		Methods:         methods,
		PayloadCodec:    kitex.Protobuf,
		KiteXGenVersion: "v0.16.0",
		Extra:           extra,
	}
	return svcInfo
}

func unitAppConfigCreateHandler(ctx context.Context, handler interface{}, arg, result interface{}) error {
	switch s := arg.(type) {
	case *streaming.Args:
		st := s.Stream
		req := new(model.UnitAppConfigCreateReq)
		if err := st.RecvMsg(req); err != nil {
			return err
		}
		resp, err := handler.(model.PsychModelService).UnitAppConfigCreate(ctx, req)
		if err != nil {
			return err
		}
		return st.SendMsg(resp)
	case *UnitAppConfigCreateArgs:
		success, err := handler.(model.PsychModelService).UnitAppConfigCreate(ctx, s.Req)
		if err != nil {
			return err
		}
		realResult := result.(*UnitAppConfigCreateResult)
		realResult.Success = success
		return nil
	default:
		return errInvalidMessageType
	}
}
func newUnitAppConfigCreateArgs() interface{} {
	return &UnitAppConfigCreateArgs{}
}

func newUnitAppConfigCreateResult() interface{} {
	return &UnitAppConfigCreateResult{}
}

type UnitAppConfigCreateArgs struct {
	Req *model.UnitAppConfigCreateReq
}

func (p *UnitAppConfigCreateArgs) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetReq() {
		return out, nil
	}
	return proto.Marshal(p.Req)
}

func (p *UnitAppConfigCreateArgs) Unmarshal(in []byte) error {
	msg := new(model.UnitAppConfigCreateReq)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Req = msg
	return nil
}

var UnitAppConfigCreateArgs_Req_DEFAULT *model.UnitAppConfigCreateReq

func (p *UnitAppConfigCreateArgs) GetReq() *model.UnitAppConfigCreateReq {
	if !p.IsSetReq() {
		return UnitAppConfigCreateArgs_Req_DEFAULT
	}
	return p.Req
}

func (p *UnitAppConfigCreateArgs) IsSetReq() bool {
	return p.Req != nil
}

func (p *UnitAppConfigCreateArgs) GetFirstArgument() interface{} {
	return p.Req
}

type UnitAppConfigCreateResult struct {
	Success *model.UnitAppConfigCreateResp
}

var UnitAppConfigCreateResult_Success_DEFAULT *model.UnitAppConfigCreateResp

func (p *UnitAppConfigCreateResult) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetSuccess() {
		return out, nil
	}
	return proto.Marshal(p.Success)
}

func (p *UnitAppConfigCreateResult) Unmarshal(in []byte) error {
	msg := new(model.UnitAppConfigCreateResp)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Success = msg
	return nil
}

func (p *UnitAppConfigCreateResult) GetSuccess() *model.UnitAppConfigCreateResp {
	if !p.IsSetSuccess() {
		return UnitAppConfigCreateResult_Success_DEFAULT
	}
	return p.Success
}

func (p *UnitAppConfigCreateResult) SetSuccess(x interface{}) {
	p.Success = x.(*model.UnitAppConfigCreateResp)
}

func (p *UnitAppConfigCreateResult) IsSetSuccess() bool {
	return p.Success != nil
}

func (p *UnitAppConfigCreateResult) GetResult() interface{} {
	return p.Success
}

func unitAppConfigUpdateHandler(ctx context.Context, handler interface{}, arg, result interface{}) error {
	switch s := arg.(type) {
	case *streaming.Args:
		st := s.Stream
		req := new(model.UnitAppConfigUpdateReq)
		if err := st.RecvMsg(req); err != nil {
			return err
		}
		resp, err := handler.(model.PsychModelService).UnitAppConfigUpdate(ctx, req)
		if err != nil {
			return err
		}
		return st.SendMsg(resp)
	case *UnitAppConfigUpdateArgs:
		success, err := handler.(model.PsychModelService).UnitAppConfigUpdate(ctx, s.Req)
		if err != nil {
			return err
		}
		realResult := result.(*UnitAppConfigUpdateResult)
		realResult.Success = success
		return nil
	default:
		return errInvalidMessageType
	}
}
func newUnitAppConfigUpdateArgs() interface{} {
	return &UnitAppConfigUpdateArgs{}
}

func newUnitAppConfigUpdateResult() interface{} {
	return &UnitAppConfigUpdateResult{}
}

type UnitAppConfigUpdateArgs struct {
	Req *model.UnitAppConfigUpdateReq
}

func (p *UnitAppConfigUpdateArgs) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetReq() {
		return out, nil
	}
	return proto.Marshal(p.Req)
}

func (p *UnitAppConfigUpdateArgs) Unmarshal(in []byte) error {
	msg := new(model.UnitAppConfigUpdateReq)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Req = msg
	return nil
}

var UnitAppConfigUpdateArgs_Req_DEFAULT *model.UnitAppConfigUpdateReq

func (p *UnitAppConfigUpdateArgs) GetReq() *model.UnitAppConfigUpdateReq {
	if !p.IsSetReq() {
		return UnitAppConfigUpdateArgs_Req_DEFAULT
	}
	return p.Req
}

func (p *UnitAppConfigUpdateArgs) IsSetReq() bool {
	return p.Req != nil
}

func (p *UnitAppConfigUpdateArgs) GetFirstArgument() interface{} {
	return p.Req
}

type UnitAppConfigUpdateResult struct {
	Success *basic.Response
}

var UnitAppConfigUpdateResult_Success_DEFAULT *basic.Response

func (p *UnitAppConfigUpdateResult) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetSuccess() {
		return out, nil
	}
	return proto.Marshal(p.Success)
}

func (p *UnitAppConfigUpdateResult) Unmarshal(in []byte) error {
	msg := new(basic.Response)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Success = msg
	return nil
}

func (p *UnitAppConfigUpdateResult) GetSuccess() *basic.Response {
	if !p.IsSetSuccess() {
		return UnitAppConfigUpdateResult_Success_DEFAULT
	}
	return p.Success
}

func (p *UnitAppConfigUpdateResult) SetSuccess(x interface{}) {
	p.Success = x.(*basic.Response)
}

func (p *UnitAppConfigUpdateResult) IsSetSuccess() bool {
	return p.Success != nil
}

func (p *UnitAppConfigUpdateResult) GetResult() interface{} {
	return p.Success
}

func unitAppConfigGetByIdHandler(ctx context.Context, handler interface{}, arg, result interface{}) error {
	switch s := arg.(type) {
	case *streaming.Args:
		st := s.Stream
		req := new(model.UnitAppConfigGetByIdReq)
		if err := st.RecvMsg(req); err != nil {
			return err
		}
		resp, err := handler.(model.PsychModelService).UnitAppConfigGetById(ctx, req)
		if err != nil {
			return err
		}
		return st.SendMsg(resp)
	case *UnitAppConfigGetByIdArgs:
		success, err := handler.(model.PsychModelService).UnitAppConfigGetById(ctx, s.Req)
		if err != nil {
			return err
		}
		realResult := result.(*UnitAppConfigGetByIdResult)
		realResult.Success = success
		return nil
	default:
		return errInvalidMessageType
	}
}
func newUnitAppConfigGetByIdArgs() interface{} {
	return &UnitAppConfigGetByIdArgs{}
}

func newUnitAppConfigGetByIdResult() interface{} {
	return &UnitAppConfigGetByIdResult{}
}

type UnitAppConfigGetByIdArgs struct {
	Req *model.UnitAppConfigGetByIdReq
}

func (p *UnitAppConfigGetByIdArgs) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetReq() {
		return out, nil
	}
	return proto.Marshal(p.Req)
}

func (p *UnitAppConfigGetByIdArgs) Unmarshal(in []byte) error {
	msg := new(model.UnitAppConfigGetByIdReq)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Req = msg
	return nil
}

var UnitAppConfigGetByIdArgs_Req_DEFAULT *model.UnitAppConfigGetByIdReq

func (p *UnitAppConfigGetByIdArgs) GetReq() *model.UnitAppConfigGetByIdReq {
	if !p.IsSetReq() {
		return UnitAppConfigGetByIdArgs_Req_DEFAULT
	}
	return p.Req
}

func (p *UnitAppConfigGetByIdArgs) IsSetReq() bool {
	return p.Req != nil
}

func (p *UnitAppConfigGetByIdArgs) GetFirstArgument() interface{} {
	return p.Req
}

type UnitAppConfigGetByIdResult struct {
	Success *model.UnitAppConfigGetByIdResp
}

var UnitAppConfigGetByIdResult_Success_DEFAULT *model.UnitAppConfigGetByIdResp

func (p *UnitAppConfigGetByIdResult) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetSuccess() {
		return out, nil
	}
	return proto.Marshal(p.Success)
}

func (p *UnitAppConfigGetByIdResult) Unmarshal(in []byte) error {
	msg := new(model.UnitAppConfigGetByIdResp)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Success = msg
	return nil
}

func (p *UnitAppConfigGetByIdResult) GetSuccess() *model.UnitAppConfigGetByIdResp {
	if !p.IsSetSuccess() {
		return UnitAppConfigGetByIdResult_Success_DEFAULT
	}
	return p.Success
}

func (p *UnitAppConfigGetByIdResult) SetSuccess(x interface{}) {
	p.Success = x.(*model.UnitAppConfigGetByIdResp)
}

func (p *UnitAppConfigGetByIdResult) IsSetSuccess() bool {
	return p.Success != nil
}

func (p *UnitAppConfigGetByIdResult) GetResult() interface{} {
	return p.Success
}

func unitAppConfigGetByUnitIdHandler(ctx context.Context, handler interface{}, arg, result interface{}) error {
	switch s := arg.(type) {
	case *streaming.Args:
		st := s.Stream
		req := new(model.UnitAppConfigGetByUnitIdReq)
		if err := st.RecvMsg(req); err != nil {
			return err
		}
		resp, err := handler.(model.PsychModelService).UnitAppConfigGetByUnitId(ctx, req)
		if err != nil {
			return err
		}
		return st.SendMsg(resp)
	case *UnitAppConfigGetByUnitIdArgs:
		success, err := handler.(model.PsychModelService).UnitAppConfigGetByUnitId(ctx, s.Req)
		if err != nil {
			return err
		}
		realResult := result.(*UnitAppConfigGetByUnitIdResult)
		realResult.Success = success
		return nil
	default:
		return errInvalidMessageType
	}
}
func newUnitAppConfigGetByUnitIdArgs() interface{} {
	return &UnitAppConfigGetByUnitIdArgs{}
}

func newUnitAppConfigGetByUnitIdResult() interface{} {
	return &UnitAppConfigGetByUnitIdResult{}
}

type UnitAppConfigGetByUnitIdArgs struct {
	Req *model.UnitAppConfigGetByUnitIdReq
}

func (p *UnitAppConfigGetByUnitIdArgs) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetReq() {
		return out, nil
	}
	return proto.Marshal(p.Req)
}

func (p *UnitAppConfigGetByUnitIdArgs) Unmarshal(in []byte) error {
	msg := new(model.UnitAppConfigGetByUnitIdReq)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Req = msg
	return nil
}

var UnitAppConfigGetByUnitIdArgs_Req_DEFAULT *model.UnitAppConfigGetByUnitIdReq

func (p *UnitAppConfigGetByUnitIdArgs) GetReq() *model.UnitAppConfigGetByUnitIdReq {
	if !p.IsSetReq() {
		return UnitAppConfigGetByUnitIdArgs_Req_DEFAULT
	}
	return p.Req
}

func (p *UnitAppConfigGetByUnitIdArgs) IsSetReq() bool {
	return p.Req != nil
}

func (p *UnitAppConfigGetByUnitIdArgs) GetFirstArgument() interface{} {
	return p.Req
}

type UnitAppConfigGetByUnitIdResult struct {
	Success *model.UnitAppConfigGetByUnitIdResp
}

var UnitAppConfigGetByUnitIdResult_Success_DEFAULT *model.UnitAppConfigGetByUnitIdResp

func (p *UnitAppConfigGetByUnitIdResult) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetSuccess() {
		return out, nil
	}
	return proto.Marshal(p.Success)
}

func (p *UnitAppConfigGetByUnitIdResult) Unmarshal(in []byte) error {
	msg := new(model.UnitAppConfigGetByUnitIdResp)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Success = msg
	return nil
}

func (p *UnitAppConfigGetByUnitIdResult) GetSuccess() *model.UnitAppConfigGetByUnitIdResp {
	if !p.IsSetSuccess() {
		return UnitAppConfigGetByUnitIdResult_Success_DEFAULT
	}
	return p.Success
}

func (p *UnitAppConfigGetByUnitIdResult) SetSuccess(x interface{}) {
	p.Success = x.(*model.UnitAppConfigGetByUnitIdResp)
}

func (p *UnitAppConfigGetByUnitIdResult) IsSetSuccess() bool {
	return p.Success != nil
}

func (p *UnitAppConfigGetByUnitIdResult) GetResult() interface{} {
	return p.Success
}

func appCreateHandler(ctx context.Context, handler interface{}, arg, result interface{}) error {
	switch s := arg.(type) {
	case *streaming.Args:
		st := s.Stream
		req := new(model.AppCreateReq)
		if err := st.RecvMsg(req); err != nil {
			return err
		}
		resp, err := handler.(model.PsychModelService).AppCreate(ctx, req)
		if err != nil {
			return err
		}
		return st.SendMsg(resp)
	case *AppCreateArgs:
		success, err := handler.(model.PsychModelService).AppCreate(ctx, s.Req)
		if err != nil {
			return err
		}
		realResult := result.(*AppCreateResult)
		realResult.Success = success
		return nil
	default:
		return errInvalidMessageType
	}
}
func newAppCreateArgs() interface{} {
	return &AppCreateArgs{}
}

func newAppCreateResult() interface{} {
	return &AppCreateResult{}
}

type AppCreateArgs struct {
	Req *model.AppCreateReq
}

func (p *AppCreateArgs) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetReq() {
		return out, nil
	}
	return proto.Marshal(p.Req)
}

func (p *AppCreateArgs) Unmarshal(in []byte) error {
	msg := new(model.AppCreateReq)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Req = msg
	return nil
}

var AppCreateArgs_Req_DEFAULT *model.AppCreateReq

func (p *AppCreateArgs) GetReq() *model.AppCreateReq {
	if !p.IsSetReq() {
		return AppCreateArgs_Req_DEFAULT
	}
	return p.Req
}

func (p *AppCreateArgs) IsSetReq() bool {
	return p.Req != nil
}

func (p *AppCreateArgs) GetFirstArgument() interface{} {
	return p.Req
}

type AppCreateResult struct {
	Success *model.AppCreateResp
}

var AppCreateResult_Success_DEFAULT *model.AppCreateResp

func (p *AppCreateResult) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetSuccess() {
		return out, nil
	}
	return proto.Marshal(p.Success)
}

func (p *AppCreateResult) Unmarshal(in []byte) error {
	msg := new(model.AppCreateResp)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Success = msg
	return nil
}

func (p *AppCreateResult) GetSuccess() *model.AppCreateResp {
	if !p.IsSetSuccess() {
		return AppCreateResult_Success_DEFAULT
	}
	return p.Success
}

func (p *AppCreateResult) SetSuccess(x interface{}) {
	p.Success = x.(*model.AppCreateResp)
}

func (p *AppCreateResult) IsSetSuccess() bool {
	return p.Success != nil
}

func (p *AppCreateResult) GetResult() interface{} {
	return p.Success
}

func appUpdateHandler(ctx context.Context, handler interface{}, arg, result interface{}) error {
	switch s := arg.(type) {
	case *streaming.Args:
		st := s.Stream
		req := new(model.AppUpdateReq)
		if err := st.RecvMsg(req); err != nil {
			return err
		}
		resp, err := handler.(model.PsychModelService).AppUpdate(ctx, req)
		if err != nil {
			return err
		}
		return st.SendMsg(resp)
	case *AppUpdateArgs:
		success, err := handler.(model.PsychModelService).AppUpdate(ctx, s.Req)
		if err != nil {
			return err
		}
		realResult := result.(*AppUpdateResult)
		realResult.Success = success
		return nil
	default:
		return errInvalidMessageType
	}
}
func newAppUpdateArgs() interface{} {
	return &AppUpdateArgs{}
}

func newAppUpdateResult() interface{} {
	return &AppUpdateResult{}
}

type AppUpdateArgs struct {
	Req *model.AppUpdateReq
}

func (p *AppUpdateArgs) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetReq() {
		return out, nil
	}
	return proto.Marshal(p.Req)
}

func (p *AppUpdateArgs) Unmarshal(in []byte) error {
	msg := new(model.AppUpdateReq)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Req = msg
	return nil
}

var AppUpdateArgs_Req_DEFAULT *model.AppUpdateReq

func (p *AppUpdateArgs) GetReq() *model.AppUpdateReq {
	if !p.IsSetReq() {
		return AppUpdateArgs_Req_DEFAULT
	}
	return p.Req
}

func (p *AppUpdateArgs) IsSetReq() bool {
	return p.Req != nil
}

func (p *AppUpdateArgs) GetFirstArgument() interface{} {
	return p.Req
}

type AppUpdateResult struct {
	Success *basic.Response
}

var AppUpdateResult_Success_DEFAULT *basic.Response

func (p *AppUpdateResult) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetSuccess() {
		return out, nil
	}
	return proto.Marshal(p.Success)
}

func (p *AppUpdateResult) Unmarshal(in []byte) error {
	msg := new(basic.Response)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Success = msg
	return nil
}

func (p *AppUpdateResult) GetSuccess() *basic.Response {
	if !p.IsSetSuccess() {
		return AppUpdateResult_Success_DEFAULT
	}
	return p.Success
}

func (p *AppUpdateResult) SetSuccess(x interface{}) {
	p.Success = x.(*basic.Response)
}

func (p *AppUpdateResult) IsSetSuccess() bool {
	return p.Success != nil
}

func (p *AppUpdateResult) GetResult() interface{} {
	return p.Success
}

func appGetByIdHandler(ctx context.Context, handler interface{}, arg, result interface{}) error {
	switch s := arg.(type) {
	case *streaming.Args:
		st := s.Stream
		req := new(model.AppGetByIdReq)
		if err := st.RecvMsg(req); err != nil {
			return err
		}
		resp, err := handler.(model.PsychModelService).AppGetById(ctx, req)
		if err != nil {
			return err
		}
		return st.SendMsg(resp)
	case *AppGetByIdArgs:
		success, err := handler.(model.PsychModelService).AppGetById(ctx, s.Req)
		if err != nil {
			return err
		}
		realResult := result.(*AppGetByIdResult)
		realResult.Success = success
		return nil
	default:
		return errInvalidMessageType
	}
}
func newAppGetByIdArgs() interface{} {
	return &AppGetByIdArgs{}
}

func newAppGetByIdResult() interface{} {
	return &AppGetByIdResult{}
}

type AppGetByIdArgs struct {
	Req *model.AppGetByIdReq
}

func (p *AppGetByIdArgs) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetReq() {
		return out, nil
	}
	return proto.Marshal(p.Req)
}

func (p *AppGetByIdArgs) Unmarshal(in []byte) error {
	msg := new(model.AppGetByIdReq)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Req = msg
	return nil
}

var AppGetByIdArgs_Req_DEFAULT *model.AppGetByIdReq

func (p *AppGetByIdArgs) GetReq() *model.AppGetByIdReq {
	if !p.IsSetReq() {
		return AppGetByIdArgs_Req_DEFAULT
	}
	return p.Req
}

func (p *AppGetByIdArgs) IsSetReq() bool {
	return p.Req != nil
}

func (p *AppGetByIdArgs) GetFirstArgument() interface{} {
	return p.Req
}

type AppGetByIdResult struct {
	Success *model.AppGetByIdResp
}

var AppGetByIdResult_Success_DEFAULT *model.AppGetByIdResp

func (p *AppGetByIdResult) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetSuccess() {
		return out, nil
	}
	return proto.Marshal(p.Success)
}

func (p *AppGetByIdResult) Unmarshal(in []byte) error {
	msg := new(model.AppGetByIdResp)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Success = msg
	return nil
}

func (p *AppGetByIdResult) GetSuccess() *model.AppGetByIdResp {
	if !p.IsSetSuccess() {
		return AppGetByIdResult_Success_DEFAULT
	}
	return p.Success
}

func (p *AppGetByIdResult) SetSuccess(x interface{}) {
	p.Success = x.(*model.AppGetByIdResp)
}

func (p *AppGetByIdResult) IsSetSuccess() bool {
	return p.Success != nil
}

func (p *AppGetByIdResult) GetResult() interface{} {
	return p.Success
}

func appGetByConfigIdHandler(ctx context.Context, handler interface{}, arg, result interface{}) error {
	switch s := arg.(type) {
	case *streaming.Args:
		st := s.Stream
		req := new(model.AppGetByConfigIdReq)
		if err := st.RecvMsg(req); err != nil {
			return err
		}
		resp, err := handler.(model.PsychModelService).AppGetByConfigId(ctx, req)
		if err != nil {
			return err
		}
		return st.SendMsg(resp)
	case *AppGetByConfigIdArgs:
		success, err := handler.(model.PsychModelService).AppGetByConfigId(ctx, s.Req)
		if err != nil {
			return err
		}
		realResult := result.(*AppGetByConfigIdResult)
		realResult.Success = success
		return nil
	default:
		return errInvalidMessageType
	}
}
func newAppGetByConfigIdArgs() interface{} {
	return &AppGetByConfigIdArgs{}
}

func newAppGetByConfigIdResult() interface{} {
	return &AppGetByConfigIdResult{}
}

type AppGetByConfigIdArgs struct {
	Req *model.AppGetByConfigIdReq
}

func (p *AppGetByConfigIdArgs) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetReq() {
		return out, nil
	}
	return proto.Marshal(p.Req)
}

func (p *AppGetByConfigIdArgs) Unmarshal(in []byte) error {
	msg := new(model.AppGetByConfigIdReq)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Req = msg
	return nil
}

var AppGetByConfigIdArgs_Req_DEFAULT *model.AppGetByConfigIdReq

func (p *AppGetByConfigIdArgs) GetReq() *model.AppGetByConfigIdReq {
	if !p.IsSetReq() {
		return AppGetByConfigIdArgs_Req_DEFAULT
	}
	return p.Req
}

func (p *AppGetByConfigIdArgs) IsSetReq() bool {
	return p.Req != nil
}

func (p *AppGetByConfigIdArgs) GetFirstArgument() interface{} {
	return p.Req
}

type AppGetByConfigIdResult struct {
	Success *model.AppGetByConfigIdResp
}

var AppGetByConfigIdResult_Success_DEFAULT *model.AppGetByConfigIdResp

func (p *AppGetByConfigIdResult) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetSuccess() {
		return out, nil
	}
	return proto.Marshal(p.Success)
}

func (p *AppGetByConfigIdResult) Unmarshal(in []byte) error {
	msg := new(model.AppGetByConfigIdResp)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Success = msg
	return nil
}

func (p *AppGetByConfigIdResult) GetSuccess() *model.AppGetByConfigIdResp {
	if !p.IsSetSuccess() {
		return AppGetByConfigIdResult_Success_DEFAULT
	}
	return p.Success
}

func (p *AppGetByConfigIdResult) SetSuccess(x interface{}) {
	p.Success = x.(*model.AppGetByConfigIdResp)
}

func (p *AppGetByConfigIdResult) IsSetSuccess() bool {
	return p.Success != nil
}

func (p *AppGetByConfigIdResult) GetResult() interface{} {
	return p.Success
}

func appListHandler(ctx context.Context, handler interface{}, arg, result interface{}) error {
	switch s := arg.(type) {
	case *streaming.Args:
		st := s.Stream
		req := new(model.AppListReq)
		if err := st.RecvMsg(req); err != nil {
			return err
		}
		resp, err := handler.(model.PsychModelService).AppList(ctx, req)
		if err != nil {
			return err
		}
		return st.SendMsg(resp)
	case *AppListArgs:
		success, err := handler.(model.PsychModelService).AppList(ctx, s.Req)
		if err != nil {
			return err
		}
		realResult := result.(*AppListResult)
		realResult.Success = success
		return nil
	default:
		return errInvalidMessageType
	}
}
func newAppListArgs() interface{} {
	return &AppListArgs{}
}

func newAppListResult() interface{} {
	return &AppListResult{}
}

type AppListArgs struct {
	Req *model.AppListReq
}

func (p *AppListArgs) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetReq() {
		return out, nil
	}
	return proto.Marshal(p.Req)
}

func (p *AppListArgs) Unmarshal(in []byte) error {
	msg := new(model.AppListReq)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Req = msg
	return nil
}

var AppListArgs_Req_DEFAULT *model.AppListReq

func (p *AppListArgs) GetReq() *model.AppListReq {
	if !p.IsSetReq() {
		return AppListArgs_Req_DEFAULT
	}
	return p.Req
}

func (p *AppListArgs) IsSetReq() bool {
	return p.Req != nil
}

func (p *AppListArgs) GetFirstArgument() interface{} {
	return p.Req
}

type AppListResult struct {
	Success *model.AppListResp
}

var AppListResult_Success_DEFAULT *model.AppListResp

func (p *AppListResult) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetSuccess() {
		return out, nil
	}
	return proto.Marshal(p.Success)
}

func (p *AppListResult) Unmarshal(in []byte) error {
	msg := new(model.AppListResp)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Success = msg
	return nil
}

func (p *AppListResult) GetSuccess() *model.AppListResp {
	if !p.IsSetSuccess() {
		return AppListResult_Success_DEFAULT
	}
	return p.Success
}

func (p *AppListResult) SetSuccess(x interface{}) {
	p.Success = x.(*model.AppListResp)
}

func (p *AppListResult) IsSetSuccess() bool {
	return p.Success != nil
}

func (p *AppListResult) GetResult() interface{} {
	return p.Success
}

func appDeleteHandler(ctx context.Context, handler interface{}, arg, result interface{}) error {
	switch s := arg.(type) {
	case *streaming.Args:
		st := s.Stream
		req := new(model.AppDeleteReq)
		if err := st.RecvMsg(req); err != nil {
			return err
		}
		resp, err := handler.(model.PsychModelService).AppDelete(ctx, req)
		if err != nil {
			return err
		}
		return st.SendMsg(resp)
	case *AppDeleteArgs:
		success, err := handler.(model.PsychModelService).AppDelete(ctx, s.Req)
		if err != nil {
			return err
		}
		realResult := result.(*AppDeleteResult)
		realResult.Success = success
		return nil
	default:
		return errInvalidMessageType
	}
}
func newAppDeleteArgs() interface{} {
	return &AppDeleteArgs{}
}

func newAppDeleteResult() interface{} {
	return &AppDeleteResult{}
}

type AppDeleteArgs struct {
	Req *model.AppDeleteReq
}

func (p *AppDeleteArgs) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetReq() {
		return out, nil
	}
	return proto.Marshal(p.Req)
}

func (p *AppDeleteArgs) Unmarshal(in []byte) error {
	msg := new(model.AppDeleteReq)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Req = msg
	return nil
}

var AppDeleteArgs_Req_DEFAULT *model.AppDeleteReq

func (p *AppDeleteArgs) GetReq() *model.AppDeleteReq {
	if !p.IsSetReq() {
		return AppDeleteArgs_Req_DEFAULT
	}
	return p.Req
}

func (p *AppDeleteArgs) IsSetReq() bool {
	return p.Req != nil
}

func (p *AppDeleteArgs) GetFirstArgument() interface{} {
	return p.Req
}

type AppDeleteResult struct {
	Success *basic.Response
}

var AppDeleteResult_Success_DEFAULT *basic.Response

func (p *AppDeleteResult) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetSuccess() {
		return out, nil
	}
	return proto.Marshal(p.Success)
}

func (p *AppDeleteResult) Unmarshal(in []byte) error {
	msg := new(basic.Response)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Success = msg
	return nil
}

func (p *AppDeleteResult) GetSuccess() *basic.Response {
	if !p.IsSetSuccess() {
		return AppDeleteResult_Success_DEFAULT
	}
	return p.Success
}

func (p *AppDeleteResult) SetSuccess(x interface{}) {
	p.Success = x.(*basic.Response)
}

func (p *AppDeleteResult) IsSetSuccess() bool {
	return p.Success != nil
}

func (p *AppDeleteResult) GetResult() interface{} {
	return p.Success
}

type kClient struct {
	c client.Client
}

func newServiceClient(c client.Client) *kClient {
	return &kClient{
		c: c,
	}
}

func (p *kClient) UnitAppConfigCreate(ctx context.Context, Req *model.UnitAppConfigCreateReq) (r *model.UnitAppConfigCreateResp, err error) {
	var _args UnitAppConfigCreateArgs
	_args.Req = Req
	var _result UnitAppConfigCreateResult
	if err = p.c.Call(ctx, "UnitAppConfigCreate", &_args, &_result); err != nil {
		return
	}
	return _result.GetSuccess(), nil
}

func (p *kClient) UnitAppConfigUpdate(ctx context.Context, Req *model.UnitAppConfigUpdateReq) (r *basic.Response, err error) {
	var _args UnitAppConfigUpdateArgs
	_args.Req = Req
	var _result UnitAppConfigUpdateResult
	if err = p.c.Call(ctx, "UnitAppConfigUpdate", &_args, &_result); err != nil {
		return
	}
	return _result.GetSuccess(), nil
}

func (p *kClient) UnitAppConfigGetById(ctx context.Context, Req *model.UnitAppConfigGetByIdReq) (r *model.UnitAppConfigGetByIdResp, err error) {
	var _args UnitAppConfigGetByIdArgs
	_args.Req = Req
	var _result UnitAppConfigGetByIdResult
	if err = p.c.Call(ctx, "UnitAppConfigGetById", &_args, &_result); err != nil {
		return
	}
	return _result.GetSuccess(), nil
}

func (p *kClient) UnitAppConfigGetByUnitId(ctx context.Context, Req *model.UnitAppConfigGetByUnitIdReq) (r *model.UnitAppConfigGetByUnitIdResp, err error) {
	var _args UnitAppConfigGetByUnitIdArgs
	_args.Req = Req
	var _result UnitAppConfigGetByUnitIdResult
	if err = p.c.Call(ctx, "UnitAppConfigGetByUnitId", &_args, &_result); err != nil {
		return
	}
	return _result.GetSuccess(), nil
}

func (p *kClient) AppCreate(ctx context.Context, Req *model.AppCreateReq) (r *model.AppCreateResp, err error) {
	var _args AppCreateArgs
	_args.Req = Req
	var _result AppCreateResult
	if err = p.c.Call(ctx, "AppCreate", &_args, &_result); err != nil {
		return
	}
	return _result.GetSuccess(), nil
}

func (p *kClient) AppUpdate(ctx context.Context, Req *model.AppUpdateReq) (r *basic.Response, err error) {
	var _args AppUpdateArgs
	_args.Req = Req
	var _result AppUpdateResult
	if err = p.c.Call(ctx, "AppUpdate", &_args, &_result); err != nil {
		return
	}
	return _result.GetSuccess(), nil
}

func (p *kClient) AppGetById(ctx context.Context, Req *model.AppGetByIdReq) (r *model.AppGetByIdResp, err error) {
	var _args AppGetByIdArgs
	_args.Req = Req
	var _result AppGetByIdResult
	if err = p.c.Call(ctx, "AppGetById", &_args, &_result); err != nil {
		return
	}
	return _result.GetSuccess(), nil
}

func (p *kClient) AppGetByConfigId(ctx context.Context, Req *model.AppGetByConfigIdReq) (r *model.AppGetByConfigIdResp, err error) {
	var _args AppGetByConfigIdArgs
	_args.Req = Req
	var _result AppGetByConfigIdResult
	if err = p.c.Call(ctx, "AppGetByConfigId", &_args, &_result); err != nil {
		return
	}
	return _result.GetSuccess(), nil
}

func (p *kClient) AppList(ctx context.Context, Req *model.AppListReq) (r *model.AppListResp, err error) {
	var _args AppListArgs
	_args.Req = Req
	var _result AppListResult
	if err = p.c.Call(ctx, "AppList", &_args, &_result); err != nil {
		return
	}
	return _result.GetSuccess(), nil
}

func (p *kClient) AppDelete(ctx context.Context, Req *model.AppDeleteReq) (r *basic.Response, err error) {
	var _args AppDeleteArgs
	_args.Req = Req
	var _result AppDeleteResult
	if err = p.c.Call(ctx, "AppDelete", &_args, &_result); err != nil {
		return
	}
	return _result.GetSuccess(), nil
}
