// Code generated by Kitex v0.14.1. DO NOT EDIT.

package psychmodelservice

import (
	"context"
	"errors"
	client "github.com/cloudwego/kitex/client"
	kitex "github.com/cloudwego/kitex/pkg/serviceinfo"
	streaming "github.com/cloudwego/kitex/pkg/streaming"
	proto "github.com/cloudwego/prutal"
	basic "github.com/xh-polaris/psych-idl/kitex_gen/basic"
	model "github.com/xh-polaris/psych-idl/kitex_gen/model"
)

var errInvalidMessageType = errors.New("invalid message type for service method handler")

var serviceMethods = map[string]kitex.MethodInfo{
	"UnitAppConfigCreate": kitex.NewMethodInfo(
		unitAppConfigCreateHandler,
		newUnitAppConfigCreateArgs,
		newUnitAppConfigCreateResult,
		false,
		kitex.WithStreamingMode(kitex.StreamingUnary),
	),
	"UnitAppConfigUpdate": kitex.NewMethodInfo(
		unitAppConfigUpdateHandler,
		newUnitAppConfigUpdateArgs,
		newUnitAppConfigUpdateResult,
		false,
		kitex.WithStreamingMode(kitex.StreamingUnary),
	),
	"UnitAppConfigGet": kitex.NewMethodInfo(
		unitAppConfigGetHandler,
		newUnitAppConfigGetArgs,
		newUnitAppConfigGetResult,
		false,
		kitex.WithStreamingMode(kitex.StreamingUnary),
	),
	"AppCreate": kitex.NewMethodInfo(
		appCreateHandler,
		newAppCreateArgs,
		newAppCreateResult,
		false,
		kitex.WithStreamingMode(kitex.StreamingUnary),
	),
	"AppUpdate": kitex.NewMethodInfo(
		appUpdateHandler,
		newAppUpdateArgs,
		newAppUpdateResult,
		false,
		kitex.WithStreamingMode(kitex.StreamingUnary),
	),
	"AppGet": kitex.NewMethodInfo(
		appGetHandler,
		newAppGetArgs,
		newAppGetResult,
		false,
		kitex.WithStreamingMode(kitex.StreamingUnary),
	),
	"AppDelete": kitex.NewMethodInfo(
		appDeleteHandler,
		newAppDeleteArgs,
		newAppDeleteResult,
		false,
		kitex.WithStreamingMode(kitex.StreamingUnary),
	),
}

var (
	psychModelServiceServiceInfo                = NewServiceInfo()
	psychModelServiceServiceInfoForClient       = NewServiceInfoForClient()
	psychModelServiceServiceInfoForStreamClient = NewServiceInfoForStreamClient()
)

// for server
func serviceInfo() *kitex.ServiceInfo {
	return psychModelServiceServiceInfo
}

// for stream client
func serviceInfoForStreamClient() *kitex.ServiceInfo {
	return psychModelServiceServiceInfoForStreamClient
}

// for client
func serviceInfoForClient() *kitex.ServiceInfo {
	return psychModelServiceServiceInfoForClient
}

// NewServiceInfo creates a new ServiceInfo containing all methods
func NewServiceInfo() *kitex.ServiceInfo {
	return newServiceInfo(false, true, true)
}

// NewServiceInfo creates a new ServiceInfo containing non-streaming methods
func NewServiceInfoForClient() *kitex.ServiceInfo {
	return newServiceInfo(false, false, true)
}
func NewServiceInfoForStreamClient() *kitex.ServiceInfo {
	return newServiceInfo(true, true, false)
}

func newServiceInfo(hasStreaming bool, keepStreamingMethods bool, keepNonStreamingMethods bool) *kitex.ServiceInfo {
	serviceName := "PsychModelService"
	handlerType := (*model.PsychModelService)(nil)
	methods := map[string]kitex.MethodInfo{}
	for name, m := range serviceMethods {
		if m.IsStreaming() && !keepStreamingMethods {
			continue
		}
		if !m.IsStreaming() && !keepNonStreamingMethods {
			continue
		}
		methods[name] = m
	}
	extra := map[string]interface{}{
		"PackageName": "model",
	}
	if hasStreaming {
		extra["streaming"] = hasStreaming
	}
	svcInfo := &kitex.ServiceInfo{
		ServiceName:     serviceName,
		HandlerType:     handlerType,
		Methods:         methods,
		PayloadCodec:    kitex.Protobuf,
		KiteXGenVersion: "v0.14.1",
		Extra:           extra,
	}
	return svcInfo
}

func unitAppConfigCreateHandler(ctx context.Context, handler interface{}, arg, result interface{}) error {
	switch s := arg.(type) {
	case *streaming.Args:
		st := s.Stream
		req := new(model.UnitAppConfigCreateReq)
		if err := st.RecvMsg(req); err != nil {
			return err
		}
		resp, err := handler.(model.PsychModelService).UnitAppConfigCreate(ctx, req)
		if err != nil {
			return err
		}
		return st.SendMsg(resp)
	case *UnitAppConfigCreateArgs:
		success, err := handler.(model.PsychModelService).UnitAppConfigCreate(ctx, s.Req)
		if err != nil {
			return err
		}
		realResult := result.(*UnitAppConfigCreateResult)
		realResult.Success = success
		return nil
	default:
		return errInvalidMessageType
	}
}
func newUnitAppConfigCreateArgs() interface{} {
	return &UnitAppConfigCreateArgs{}
}

func newUnitAppConfigCreateResult() interface{} {
	return &UnitAppConfigCreateResult{}
}

type UnitAppConfigCreateArgs struct {
	Req *model.UnitAppConfigCreateReq
}

func (p *UnitAppConfigCreateArgs) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetReq() {
		return out, nil
	}
	return proto.Marshal(p.Req)
}

func (p *UnitAppConfigCreateArgs) Unmarshal(in []byte) error {
	msg := new(model.UnitAppConfigCreateReq)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Req = msg
	return nil
}

var UnitAppConfigCreateArgs_Req_DEFAULT *model.UnitAppConfigCreateReq

func (p *UnitAppConfigCreateArgs) GetReq() *model.UnitAppConfigCreateReq {
	if !p.IsSetReq() {
		return UnitAppConfigCreateArgs_Req_DEFAULT
	}
	return p.Req
}

func (p *UnitAppConfigCreateArgs) IsSetReq() bool {
	return p.Req != nil
}

func (p *UnitAppConfigCreateArgs) GetFirstArgument() interface{} {
	return p.Req
}

type UnitAppConfigCreateResult struct {
	Success *model.UnitAppConfigCreateResp
}

var UnitAppConfigCreateResult_Success_DEFAULT *model.UnitAppConfigCreateResp

func (p *UnitAppConfigCreateResult) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetSuccess() {
		return out, nil
	}
	return proto.Marshal(p.Success)
}

func (p *UnitAppConfigCreateResult) Unmarshal(in []byte) error {
	msg := new(model.UnitAppConfigCreateResp)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Success = msg
	return nil
}

func (p *UnitAppConfigCreateResult) GetSuccess() *model.UnitAppConfigCreateResp {
	if !p.IsSetSuccess() {
		return UnitAppConfigCreateResult_Success_DEFAULT
	}
	return p.Success
}

func (p *UnitAppConfigCreateResult) SetSuccess(x interface{}) {
	p.Success = x.(*model.UnitAppConfigCreateResp)
}

func (p *UnitAppConfigCreateResult) IsSetSuccess() bool {
	return p.Success != nil
}

func (p *UnitAppConfigCreateResult) GetResult() interface{} {
	return p.Success
}

func unitAppConfigUpdateHandler(ctx context.Context, handler interface{}, arg, result interface{}) error {
	switch s := arg.(type) {
	case *streaming.Args:
		st := s.Stream
		req := new(model.UnitAppConfigUpdateReq)
		if err := st.RecvMsg(req); err != nil {
			return err
		}
		resp, err := handler.(model.PsychModelService).UnitAppConfigUpdate(ctx, req)
		if err != nil {
			return err
		}
		return st.SendMsg(resp)
	case *UnitAppConfigUpdateArgs:
		success, err := handler.(model.PsychModelService).UnitAppConfigUpdate(ctx, s.Req)
		if err != nil {
			return err
		}
		realResult := result.(*UnitAppConfigUpdateResult)
		realResult.Success = success
		return nil
	default:
		return errInvalidMessageType
	}
}
func newUnitAppConfigUpdateArgs() interface{} {
	return &UnitAppConfigUpdateArgs{}
}

func newUnitAppConfigUpdateResult() interface{} {
	return &UnitAppConfigUpdateResult{}
}

type UnitAppConfigUpdateArgs struct {
	Req *model.UnitAppConfigUpdateReq
}

func (p *UnitAppConfigUpdateArgs) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetReq() {
		return out, nil
	}
	return proto.Marshal(p.Req)
}

func (p *UnitAppConfigUpdateArgs) Unmarshal(in []byte) error {
	msg := new(model.UnitAppConfigUpdateReq)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Req = msg
	return nil
}

var UnitAppConfigUpdateArgs_Req_DEFAULT *model.UnitAppConfigUpdateReq

func (p *UnitAppConfigUpdateArgs) GetReq() *model.UnitAppConfigUpdateReq {
	if !p.IsSetReq() {
		return UnitAppConfigUpdateArgs_Req_DEFAULT
	}
	return p.Req
}

func (p *UnitAppConfigUpdateArgs) IsSetReq() bool {
	return p.Req != nil
}

func (p *UnitAppConfigUpdateArgs) GetFirstArgument() interface{} {
	return p.Req
}

type UnitAppConfigUpdateResult struct {
	Success *basic.Response
}

var UnitAppConfigUpdateResult_Success_DEFAULT *basic.Response

func (p *UnitAppConfigUpdateResult) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetSuccess() {
		return out, nil
	}
	return proto.Marshal(p.Success)
}

func (p *UnitAppConfigUpdateResult) Unmarshal(in []byte) error {
	msg := new(basic.Response)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Success = msg
	return nil
}

func (p *UnitAppConfigUpdateResult) GetSuccess() *basic.Response {
	if !p.IsSetSuccess() {
		return UnitAppConfigUpdateResult_Success_DEFAULT
	}
	return p.Success
}

func (p *UnitAppConfigUpdateResult) SetSuccess(x interface{}) {
	p.Success = x.(*basic.Response)
}

func (p *UnitAppConfigUpdateResult) IsSetSuccess() bool {
	return p.Success != nil
}

func (p *UnitAppConfigUpdateResult) GetResult() interface{} {
	return p.Success
}

func unitAppConfigGetHandler(ctx context.Context, handler interface{}, arg, result interface{}) error {
	switch s := arg.(type) {
	case *streaming.Args:
		st := s.Stream
		req := new(model.UnitAppConfigGetReq)
		if err := st.RecvMsg(req); err != nil {
			return err
		}
		resp, err := handler.(model.PsychModelService).UnitAppConfigGet(ctx, req)
		if err != nil {
			return err
		}
		return st.SendMsg(resp)
	case *UnitAppConfigGetArgs:
		success, err := handler.(model.PsychModelService).UnitAppConfigGet(ctx, s.Req)
		if err != nil {
			return err
		}
		realResult := result.(*UnitAppConfigGetResult)
		realResult.Success = success
		return nil
	default:
		return errInvalidMessageType
	}
}
func newUnitAppConfigGetArgs() interface{} {
	return &UnitAppConfigGetArgs{}
}

func newUnitAppConfigGetResult() interface{} {
	return &UnitAppConfigGetResult{}
}

type UnitAppConfigGetArgs struct {
	Req *model.UnitAppConfigGetReq
}

func (p *UnitAppConfigGetArgs) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetReq() {
		return out, nil
	}
	return proto.Marshal(p.Req)
}

func (p *UnitAppConfigGetArgs) Unmarshal(in []byte) error {
	msg := new(model.UnitAppConfigGetReq)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Req = msg
	return nil
}

var UnitAppConfigGetArgs_Req_DEFAULT *model.UnitAppConfigGetReq

func (p *UnitAppConfigGetArgs) GetReq() *model.UnitAppConfigGetReq {
	if !p.IsSetReq() {
		return UnitAppConfigGetArgs_Req_DEFAULT
	}
	return p.Req
}

func (p *UnitAppConfigGetArgs) IsSetReq() bool {
	return p.Req != nil
}

func (p *UnitAppConfigGetArgs) GetFirstArgument() interface{} {
	return p.Req
}

type UnitAppConfigGetResult struct {
	Success *model.UnitAppConfigGetResp
}

var UnitAppConfigGetResult_Success_DEFAULT *model.UnitAppConfigGetResp

func (p *UnitAppConfigGetResult) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetSuccess() {
		return out, nil
	}
	return proto.Marshal(p.Success)
}

func (p *UnitAppConfigGetResult) Unmarshal(in []byte) error {
	msg := new(model.UnitAppConfigGetResp)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Success = msg
	return nil
}

func (p *UnitAppConfigGetResult) GetSuccess() *model.UnitAppConfigGetResp {
	if !p.IsSetSuccess() {
		return UnitAppConfigGetResult_Success_DEFAULT
	}
	return p.Success
}

func (p *UnitAppConfigGetResult) SetSuccess(x interface{}) {
	p.Success = x.(*model.UnitAppConfigGetResp)
}

func (p *UnitAppConfigGetResult) IsSetSuccess() bool {
	return p.Success != nil
}

func (p *UnitAppConfigGetResult) GetResult() interface{} {
	return p.Success
}

func appCreateHandler(ctx context.Context, handler interface{}, arg, result interface{}) error {
	switch s := arg.(type) {
	case *streaming.Args:
		st := s.Stream
		req := new(model.AppCreateReq)
		if err := st.RecvMsg(req); err != nil {
			return err
		}
		resp, err := handler.(model.PsychModelService).AppCreate(ctx, req)
		if err != nil {
			return err
		}
		return st.SendMsg(resp)
	case *AppCreateArgs:
		success, err := handler.(model.PsychModelService).AppCreate(ctx, s.Req)
		if err != nil {
			return err
		}
		realResult := result.(*AppCreateResult)
		realResult.Success = success
		return nil
	default:
		return errInvalidMessageType
	}
}
func newAppCreateArgs() interface{} {
	return &AppCreateArgs{}
}

func newAppCreateResult() interface{} {
	return &AppCreateResult{}
}

type AppCreateArgs struct {
	Req *model.AppCreateReq
}

func (p *AppCreateArgs) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetReq() {
		return out, nil
	}
	return proto.Marshal(p.Req)
}

func (p *AppCreateArgs) Unmarshal(in []byte) error {
	msg := new(model.AppCreateReq)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Req = msg
	return nil
}

var AppCreateArgs_Req_DEFAULT *model.AppCreateReq

func (p *AppCreateArgs) GetReq() *model.AppCreateReq {
	if !p.IsSetReq() {
		return AppCreateArgs_Req_DEFAULT
	}
	return p.Req
}

func (p *AppCreateArgs) IsSetReq() bool {
	return p.Req != nil
}

func (p *AppCreateArgs) GetFirstArgument() interface{} {
	return p.Req
}

type AppCreateResult struct {
	Success *model.AppCreateResp
}

var AppCreateResult_Success_DEFAULT *model.AppCreateResp

func (p *AppCreateResult) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetSuccess() {
		return out, nil
	}
	return proto.Marshal(p.Success)
}

func (p *AppCreateResult) Unmarshal(in []byte) error {
	msg := new(model.AppCreateResp)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Success = msg
	return nil
}

func (p *AppCreateResult) GetSuccess() *model.AppCreateResp {
	if !p.IsSetSuccess() {
		return AppCreateResult_Success_DEFAULT
	}
	return p.Success
}

func (p *AppCreateResult) SetSuccess(x interface{}) {
	p.Success = x.(*model.AppCreateResp)
}

func (p *AppCreateResult) IsSetSuccess() bool {
	return p.Success != nil
}

func (p *AppCreateResult) GetResult() interface{} {
	return p.Success
}

func appUpdateHandler(ctx context.Context, handler interface{}, arg, result interface{}) error {
	switch s := arg.(type) {
	case *streaming.Args:
		st := s.Stream
		req := new(model.AppUpdateReq)
		if err := st.RecvMsg(req); err != nil {
			return err
		}
		resp, err := handler.(model.PsychModelService).AppUpdate(ctx, req)
		if err != nil {
			return err
		}
		return st.SendMsg(resp)
	case *AppUpdateArgs:
		success, err := handler.(model.PsychModelService).AppUpdate(ctx, s.Req)
		if err != nil {
			return err
		}
		realResult := result.(*AppUpdateResult)
		realResult.Success = success
		return nil
	default:
		return errInvalidMessageType
	}
}
func newAppUpdateArgs() interface{} {
	return &AppUpdateArgs{}
}

func newAppUpdateResult() interface{} {
	return &AppUpdateResult{}
}

type AppUpdateArgs struct {
	Req *model.AppUpdateReq
}

func (p *AppUpdateArgs) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetReq() {
		return out, nil
	}
	return proto.Marshal(p.Req)
}

func (p *AppUpdateArgs) Unmarshal(in []byte) error {
	msg := new(model.AppUpdateReq)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Req = msg
	return nil
}

var AppUpdateArgs_Req_DEFAULT *model.AppUpdateReq

func (p *AppUpdateArgs) GetReq() *model.AppUpdateReq {
	if !p.IsSetReq() {
		return AppUpdateArgs_Req_DEFAULT
	}
	return p.Req
}

func (p *AppUpdateArgs) IsSetReq() bool {
	return p.Req != nil
}

func (p *AppUpdateArgs) GetFirstArgument() interface{} {
	return p.Req
}

type AppUpdateResult struct {
	Success *basic.Response
}

var AppUpdateResult_Success_DEFAULT *basic.Response

func (p *AppUpdateResult) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetSuccess() {
		return out, nil
	}
	return proto.Marshal(p.Success)
}

func (p *AppUpdateResult) Unmarshal(in []byte) error {
	msg := new(basic.Response)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Success = msg
	return nil
}

func (p *AppUpdateResult) GetSuccess() *basic.Response {
	if !p.IsSetSuccess() {
		return AppUpdateResult_Success_DEFAULT
	}
	return p.Success
}

func (p *AppUpdateResult) SetSuccess(x interface{}) {
	p.Success = x.(*basic.Response)
}

func (p *AppUpdateResult) IsSetSuccess() bool {
	return p.Success != nil
}

func (p *AppUpdateResult) GetResult() interface{} {
	return p.Success
}

func appGetHandler(ctx context.Context, handler interface{}, arg, result interface{}) error {
	switch s := arg.(type) {
	case *streaming.Args:
		st := s.Stream
		req := new(model.AppGetByUnitIdReq)
		if err := st.RecvMsg(req); err != nil {
			return err
		}
		resp, err := handler.(model.PsychModelService).AppGet(ctx, req)
		if err != nil {
			return err
		}
		return st.SendMsg(resp)
	case *AppGetArgs:
		success, err := handler.(model.PsychModelService).AppGet(ctx, s.Req)
		if err != nil {
			return err
		}
		realResult := result.(*AppGetResult)
		realResult.Success = success
		return nil
	default:
		return errInvalidMessageType
	}
}
func newAppGetArgs() interface{} {
	return &AppGetArgs{}
}

func newAppGetResult() interface{} {
	return &AppGetResult{}
}

type AppGetArgs struct {
	Req *model.AppGetByUnitIdReq
}

func (p *AppGetArgs) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetReq() {
		return out, nil
	}
	return proto.Marshal(p.Req)
}

func (p *AppGetArgs) Unmarshal(in []byte) error {
	msg := new(model.AppGetByUnitIdReq)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Req = msg
	return nil
}

var AppGetArgs_Req_DEFAULT *model.AppGetByUnitIdReq

func (p *AppGetArgs) GetReq() *model.AppGetByUnitIdReq {
	if !p.IsSetReq() {
		return AppGetArgs_Req_DEFAULT
	}
	return p.Req
}

func (p *AppGetArgs) IsSetReq() bool {
	return p.Req != nil
}

func (p *AppGetArgs) GetFirstArgument() interface{} {
	return p.Req
}

type AppGetResult struct {
	Success *model.AppGetByUnitIdResp
}

var AppGetResult_Success_DEFAULT *model.AppGetByUnitIdResp

func (p *AppGetResult) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetSuccess() {
		return out, nil
	}
	return proto.Marshal(p.Success)
}

func (p *AppGetResult) Unmarshal(in []byte) error {
	msg := new(model.AppGetByUnitIdResp)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Success = msg
	return nil
}

func (p *AppGetResult) GetSuccess() *model.AppGetByUnitIdResp {
	if !p.IsSetSuccess() {
		return AppGetResult_Success_DEFAULT
	}
	return p.Success
}

func (p *AppGetResult) SetSuccess(x interface{}) {
	p.Success = x.(*model.AppGetByUnitIdResp)
}

func (p *AppGetResult) IsSetSuccess() bool {
	return p.Success != nil
}

func (p *AppGetResult) GetResult() interface{} {
	return p.Success
}

func appDeleteHandler(ctx context.Context, handler interface{}, arg, result interface{}) error {
	switch s := arg.(type) {
	case *streaming.Args:
		st := s.Stream
		req := new(model.AppDeleteReq)
		if err := st.RecvMsg(req); err != nil {
			return err
		}
		resp, err := handler.(model.PsychModelService).AppDelete(ctx, req)
		if err != nil {
			return err
		}
		return st.SendMsg(resp)
	case *AppDeleteArgs:
		success, err := handler.(model.PsychModelService).AppDelete(ctx, s.Req)
		if err != nil {
			return err
		}
		realResult := result.(*AppDeleteResult)
		realResult.Success = success
		return nil
	default:
		return errInvalidMessageType
	}
}
func newAppDeleteArgs() interface{} {
	return &AppDeleteArgs{}
}

func newAppDeleteResult() interface{} {
	return &AppDeleteResult{}
}

type AppDeleteArgs struct {
	Req *model.AppDeleteReq
}

func (p *AppDeleteArgs) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetReq() {
		return out, nil
	}
	return proto.Marshal(p.Req)
}

func (p *AppDeleteArgs) Unmarshal(in []byte) error {
	msg := new(model.AppDeleteReq)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Req = msg
	return nil
}

var AppDeleteArgs_Req_DEFAULT *model.AppDeleteReq

func (p *AppDeleteArgs) GetReq() *model.AppDeleteReq {
	if !p.IsSetReq() {
		return AppDeleteArgs_Req_DEFAULT
	}
	return p.Req
}

func (p *AppDeleteArgs) IsSetReq() bool {
	return p.Req != nil
}

func (p *AppDeleteArgs) GetFirstArgument() interface{} {
	return p.Req
}

type AppDeleteResult struct {
	Success *basic.Response
}

var AppDeleteResult_Success_DEFAULT *basic.Response

func (p *AppDeleteResult) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetSuccess() {
		return out, nil
	}
	return proto.Marshal(p.Success)
}

func (p *AppDeleteResult) Unmarshal(in []byte) error {
	msg := new(basic.Response)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Success = msg
	return nil
}

func (p *AppDeleteResult) GetSuccess() *basic.Response {
	if !p.IsSetSuccess() {
		return AppDeleteResult_Success_DEFAULT
	}
	return p.Success
}

func (p *AppDeleteResult) SetSuccess(x interface{}) {
	p.Success = x.(*basic.Response)
}

func (p *AppDeleteResult) IsSetSuccess() bool {
	return p.Success != nil
}

func (p *AppDeleteResult) GetResult() interface{} {
	return p.Success
}

type kClient struct {
	c client.Client
}

func newServiceClient(c client.Client) *kClient {
	return &kClient{
		c: c,
	}
}

func (p *kClient) UnitAppConfigCreate(ctx context.Context, Req *model.UnitAppConfigCreateReq) (r *model.UnitAppConfigCreateResp, err error) {
	var _args UnitAppConfigCreateArgs
	_args.Req = Req
	var _result UnitAppConfigCreateResult
	if err = p.c.Call(ctx, "UnitAppConfigCreate", &_args, &_result); err != nil {
		return
	}
	return _result.GetSuccess(), nil
}

func (p *kClient) UnitAppConfigUpdate(ctx context.Context, Req *model.UnitAppConfigUpdateReq) (r *basic.Response, err error) {
	var _args UnitAppConfigUpdateArgs
	_args.Req = Req
	var _result UnitAppConfigUpdateResult
	if err = p.c.Call(ctx, "UnitAppConfigUpdate", &_args, &_result); err != nil {
		return
	}
	return _result.GetSuccess(), nil
}

func (p *kClient) UnitAppConfigGet(ctx context.Context, Req *model.UnitAppConfigGetReq) (r *model.UnitAppConfigGetResp, err error) {
	var _args UnitAppConfigGetArgs
	_args.Req = Req
	var _result UnitAppConfigGetResult
	if err = p.c.Call(ctx, "UnitAppConfigGet", &_args, &_result); err != nil {
		return
	}
	return _result.GetSuccess(), nil
}

func (p *kClient) AppCreate(ctx context.Context, Req *model.AppCreateReq) (r *model.AppCreateResp, err error) {
	var _args AppCreateArgs
	_args.Req = Req
	var _result AppCreateResult
	if err = p.c.Call(ctx, "AppCreate", &_args, &_result); err != nil {
		return
	}
	return _result.GetSuccess(), nil
}

func (p *kClient) AppUpdate(ctx context.Context, Req *model.AppUpdateReq) (r *basic.Response, err error) {
	var _args AppUpdateArgs
	_args.Req = Req
	var _result AppUpdateResult
	if err = p.c.Call(ctx, "AppUpdate", &_args, &_result); err != nil {
		return
	}
	return _result.GetSuccess(), nil
}

func (p *kClient) AppGet(ctx context.Context, Req *model.AppGetByUnitIdReq) (r *model.AppGetByUnitIdResp, err error) {
	var _args AppGetArgs
	_args.Req = Req
	var _result AppGetResult
	if err = p.c.Call(ctx, "AppGet", &_args, &_result); err != nil {
		return
	}
	return _result.GetSuccess(), nil
}

func (p *kClient) AppDelete(ctx context.Context, Req *model.AppDeleteReq) (r *basic.Response, err error) {
	var _args AppDeleteArgs
	_args.Req = Req
	var _result AppDeleteResult
	if err = p.c.Call(ctx, "AppDelete", &_args, &_result); err != nil {
		return
	}
	return _result.GetSuccess(), nil
}
